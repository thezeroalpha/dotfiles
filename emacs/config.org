* Keep track of custom key bindings
I want an easy way to see which global key bindings I have.
Some packages provide things like this, but I want it to be simple and always available, so I'll roll my own.
These functions allow a way to store personal global key bindings and view them as a list.

I'll use a hash table to map a key (in ~kbd~ format, the inverse of this is ~key-description~) to its function (and its previous function):

#+begin_src emacs-lisp
  (setq za/personal-keybinds (make-hash-table :test 'equal))
#+end_src

A function to bind keys:

#+begin_src emacs-lisp
  (defun za/global-set-key (keys fun)
    "Bind KEYS to FUN. This will be saved to the za/personal-keybinds hash table."
    (let* (;; Store the previous function KEYS were bound to
           (lookup-result (lookup-key (current-global-map) keys))
           (previous-fun (cond ((not lookup-result) nil)
                               ((numberp lookup-result) nil)
                               ((equal lookup-result fun) nil)
                               (t lookup-result)))
           ;; Try to see if it already has a custom binding
           (existing-entry (gethash keys za/personal-keybinds)))

      ;; If KEYS already have a custom binding, fail, unless we're just repeating the same binding
      (if (and existing-entry
               (not (equal (car existing-entry) fun)))
          (user-error (format "Keys are already bound to %s" (car existing-entry))))

      (puthash keys (list fun previous-fun) za/personal-keybinds)
      (global-set-key keys fun)))
#+end_src

And one to remove bindings:

#+begin_src emacs-lisp
  (defun za/global-unset-key (keys)
    "Remove a custom key binding from za/personal-keybinds and unbind the keys."
    (remhash keys za/personal-keybinds)
    (global-unset-key keys))
#+end_src

Then a way to retrieve keybindings:

#+begin_src emacs-lisp
  (defun za/get-personal-keybinds ()
    "Return the contents of za/personal-keybinds as a string."
    (let (result
          (format-entry (lambda (k v)
                          (let ((get-func (lambda (e) (nth 0 e)))
                                (get-prev-func (lambda (e) (nth 1 e))))
                            (push
                             (concat (format "%s\t\t%s" (key-description k) (funcall get-func v))
                                     (if (funcall get-prev-func v)
                                         (format "\t\t(previously %s)" (funcall get-prev-func v))))
                             result)))))
      (maphash format-entry za/personal-keybinds)
      (mapconcat 'identity (sort result 'string<) "\n")))
#+end_src
(za/global-unset-key (kbd "C-x C-s"))
And a way to display all of the keybindings:

#+begin_src emacs-lisp
  (defun za/list-personal-keybinds ()
    (interactive)
    (with-output-to-temp-buffer "*Personal Keybindings*"
      (princ (za/get-personal-keybinds))))
#+end_src

* Emacs file locations
** Auto-Save files
By default, auto-save files ("#file#") are placed in the same directory as the file itself.
I want to put this all in some unified place:

#+begin_src emacs-lisp
  (let ((saves-directory "~/.local/share/emacs/saves/"))
    (unless (file-directory-p saves-directory)
      (make-directory saves-directory))
    (setq auto-save-file-name-transforms
          `((".*" ,saves-directory t))))
#+end_src

** Backup files
By default, backup files (those with a tilde) are saved in the same directory as the currently edited file.
This setting puts them in ~/.local/share/emacs/backups.

#+begin_src emacs-lisp
  (let ((backups-directory "~/.local/share/emacs/backups"))
    (unless (file-directory-p backups-directory)
      (make-directory backups-directory))
    (setq backup-directory-alist `(("." . ,backups-directory)))
    (setq backup-by-copying t))
#+end_src

** Custom settings file
Both commands are necessary.
First one tells Emacs where to save customizations.
The second one actually loads them.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
  (load custom-file)
#+end_src
* Theme
Icons required for some parts of the doom theme:

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

Load Doom Emacs themes:

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)

    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

Define the themes I want:

#+begin_src emacs-lisp
  (setq za/dark-theme-name 'doom-one)
  (setq za/light-theme-name 'jokull)
  ;; I used to use doom-acario-light before writing my own theme

  (defun za/dark-theme ()
    "Switch to dark theme"
    (interactive)
    (mapcar #'disable-theme custom-enabled-themes)
    (load-theme za/dark-theme-name t)
    (add-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode))

  (defun za/light-theme ()
    "Switch to light theme"
    (interactive)
    (mapcar #'disable-theme custom-enabled-themes)
    (load-theme za/light-theme-name t)
    (remove-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode))
#+end_src

Change theme depending on the current system theme.
The way I check for dark mode is defined in 'dark-mode-p'; currently I use the presence of the ~/.config/dark-theme file to indicate when dark theme is set.
I quote the call to ~file-exists-p~ because I want to evaluate it on-demand, not immediately.
A function ending in '-p' is a predicate, i.e. returns true or false.
If calling a function that's in a variable, you have to use 'funcall'.
To evaluate a quoted form, use 'eval'.

#+begin_src emacs-lisp
  (defun za/auto-select-theme (&rest _)
    "Automatically select dark/light theme based on presence of ~/.config/dark-theme"
    (let ((dark-mode-p '(file-exists-p "~/.config/dark-theme")))
      (if (eval dark-mode-p)
          (za/dark-theme)
        (za/light-theme))))

  (za/auto-select-theme)
#+end_src

* Font
I want Menlo, size 14:

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Menlo-14"))
#+end_src

* Garbage collection
Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+begin_src emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+end_src

* Packages
** quelpa
Quelpa lets you install from local or remote source (like git).
With quelpa-use-package, I can use the keyword ~:quelpa~ to install via quelpa.

#+begin_src emacs-lisp
  (use-package quelpa)
  (use-package quelpa-use-package)
#+end_src

** exec-path-from-shell (macOS)
In macOS, the path is not set correctly (i.e. as it is in the terminal) in the GUI app. This fixes it.

#+begin_src emacs-lisp
  (when (string-equal system-type "darwin")
    (use-package exec-path-from-shell
      :config
      (add-to-list 'exec-path-from-shell-variables "NOTMUCH_CONFIG")
      (exec-path-from-shell-initialize)))
#+end_src

** emacs-which-key
Minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src

** counsel + ivy + swiper
Better incremental completion and selection narrowing.
And a bunch more.
Generally makes for nicer interactivity, like ido mode on steroids.
Switched to this from Helm, it's more lightweight.

#+begin_src emacs-lisp
  (use-package counsel :demand
    :config
    (setq ivy-use-virtual-buffers t       ; extend searching to bookmarks and
          ivy-height 20                   ; set height of the ivy window
          ivy-count-format "(%d/%d) "     ; count format, from the ivy help page
          ivy-display-style 'fancy
          ivy-format-function 'ivy-format-function-line)
    (ivy-mode)
    (counsel-mode)

    (defun edit-script ()
      "Edit a file in ~/.scripts/"
      (interactive)
      (let ((input (ivy--input)))
        (ivy-quit-and-run (counsel-file-jump nil "~/.scripts/"))))
    (defun edit-config ()
      "Edit a file in ~/.dotfiles/"
      (interactive)
      (let ((input (ivy--input)))
        (ivy-quit-and-run (counsel-file-jump nil "~/.dotfiles/")))))
#+end_src

Set the key bindings:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-s") #'swiper-isearch)
  (za/global-set-key (kbd "C-r") #'swiper-isearch-backward)
  (za/global-set-key (kbd "M-x") #'counsel-M-x)
  (za/global-set-key (kbd "C-x C-f") #'counsel-find-file)
  (za/global-set-key (kbd "M-y") #'counsel-yank-pop)
  (za/global-set-key (kbd "C-x b") #'ivy-switch-buffer)
  (za/global-set-key (kbd "C-c v") #'ivy-push-view)
  (za/global-set-key (kbd "C-c V") #'ivy-pop-view)
  (za/global-set-key (kbd "C-c c") #'counsel-compile)
  (za/global-set-key (kbd "C-c k") #'counsel-ag)
  (za/global-set-key (kbd "C-c f") #'counsel-fzf)
  (za/global-set-key (kbd "C-c b") #'counsel-bookmark)
  (za/global-set-key (kbd "C-c p") #'counsel-recentf)
  (za/global-set-key (kbd "C-c o") #'counsel-outline)
#+end_src

I like having ivy in a popup.
Problem: posframe does not work if emacs is too old and on macos.
See here: https://github.com/tumashu/posframe/issues/30
On Mac, ~brew install --HEAD emacs~ doesn't work either.
Solution: ~brew tap daviderestivo/emacs-head && brew install emacs-head@28 --with-cocoa~

#+begin_src emacs-lisp
  (if (and ( version< emacs-version "28") (equal system-type 'darwin))
      (message "ivy-posframe won't work properly, run `brew install daviderestivo/emacs-head/emacs-head@28 --with-cocoa`")
    (use-package ivy-posframe
      :config
      (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
      (setq ivy-posframe-parameters
            '((left-fringe . 8)
              (right-fringe . 8)))
      (setq ivy-posframe-border-width 3)
      (custom-set-faces '(ivy-posframe-border ((t (:inherit mode-line-inactive)))))
      (ivy-posframe-mode 1)))
#+end_src

Have to set this to let me select exactly what I'm typing as a candidate:

#+begin_src emacs-lisp
  (setq ivy-use-selectable-prompt t)
#+end_src

Also, accidentally pressing shift-space deletes input, because by default, shift-space is bound to ~ivy-restrict-to-matches~ in the ivy minibuffer. I don't want that, I want it bound to shift-tab:

#+begin_src emacs-lisp
  (define-key ivy-minibuffer-map (kbd "S-SPC") (lambda () (interactive) (insert ?\s)))
  (define-key ivy-minibuffer-map (kbd "<backtab>") #'ivy-restrict-to-matches)
#+end_src

** company
Good completion.

#+begin_src emacs-lisp
  (use-package company
    :hook (ledger-mode . company-mode))
#+end_src
** wgrep
#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src
** avy
This lets me jump to any position in Emacs rather quickly, sometimes it's useful.
~avy-goto-char-timer~ lets me type a part of the text before avy kicks in.

#+begin_src emacs-lisp
  (use-package avy
    :bind
    (("C-:" . 'avy-goto-char-timer)))
#+end_src

** Org
*** Installation
Install Org and require additional components that I use.

#+begin_src emacs-lisp
    (use-package org
      :config
      (require 'org-tempo)
      (require 'org-habit)
      (require 'org-agenda)
      (require 'org-id))
#+end_src

*** Key bindings
Global:
#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c a") #'org-agenda)
  (za/global-set-key (kbd "C-c n") #'org-capture)
  (za/global-set-key (kbd "C-c l") #'org-store-link)
#+end_src

Org mode:
#+begin_src emacs-lisp
    (defun za/keybinds-org-mode ()
      "Function to set org-mode keybindings, run via org-mode-hook."
      (define-key org-mode-map (kbd "C-M-<return>") #'org-insert-todo-heading)
      (define-key org-mode-map (kbd "C-c M-y") #'org-yank-link-url)
      (define-key org-mode-map (kbd "C-c N") #'org-noter)
      (define-key org-mode-map (kbd "C-M-i") #'completion-at-point))

    (add-hook 'org-mode-hook #'za/keybinds-org-mode)
#+end_src
*** Nicer bullets
In org mode, I want to use bullets instead of stars, so I also install ~org-superstar~.

#+begin_src emacs-lisp
  (use-package org-superstar
    :config
    (setq org-superstar-leading-bullet ?\s))
#+end_src

*** More languages
#+begin_src emacs-lisp
(use-package inf-ruby)
#+end_src
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (R . t)
     (python . t)
     (ruby . t)))

  (setq org-babel-python-command "python3")
  (setq org-confirm-babel-evaluate nil)
#+end_src
*** Org mode settings
Furthermore, tags were getting cut off, so I manually set the best column to display them.

#+begin_src emacs-lisp
  (defun za/settings-org-mode ()
    "My settings for org mode"
    (org-superstar-mode 1)
    (za/toggle-wrap t)
    (org-indent-mode)
    (setq org-tags-column (- 10 (window-total-width)))
    (setq org-src-tab-acts-natively t)    ; a tab in a code block indents the code as it should
    ;; Realign tags
    (org-set-tags-command '(4)))

  (add-hook 'org-mode-hook #'za/settings-org-mode)
#+end_src

Link settings:

#+begin_src emacs-lisp
  (setq org-link-elisp-confirm-function #'y-or-n-p
        org-link-elisp-skip-confirm-regexp "^org-noter$")
#+end_src

*** Enable linking to email via notmuch
To be able to link to emails via notmuch, I use ol-notmuch:

#+begin_src emacs-lisp
  (use-package ol-notmuch :quelpa)
#+end_src

*** Agenda & GTD
**** Agenda mode settings
Fix tag display by dynamically calculating the column.

#+begin_src emacs-lisp
  (defun za/settings-org-agenda-mode ()
    "My settings for org agenda mode"
    (setq org-agenda-tags-column (- 10 (window-total-width))))

  (add-hook 'org-agenda-mode-hook #'za/settings-org-agenda-mode)
#+end_src

**** Set file locations
Which files should be included in the agenda (I have to use ~list~ to evaluate the variables, because org-agenda-files expects strings):

#+begin_src emacs-lisp
  (setq org-agenda-files (list za/org-life-main
                               za/org-life-inbox
                               za/org-life-tickler))
#+end_src

I want to search all Org files in the life directory:

#+begin_src emacs-lisp
  (setq org-agenda-text-search-extra-files (directory-files za/org-life-dir t (rx bol (not ?.) (* anything) ".org")))
#+end_src

Convenience functions to make opening the main file faster:

#+begin_src emacs-lisp
  (defun gtd () "GTD: main file" (interactive) (find-file za/org-life-main))
  (defun gtd-inbox () "GTD: inbox" (interactive) (find-file za/org-life-inbox))
  (defun gtd-archive () "GTD: archive" (interactive) (find-file za/org-life-archive))
  (defun gtd-someday () "GTD: someday" (interactive) (find-file za/org-life-someday))
  (defun gtd-tickler () "GTD: tickler" (interactive) (find-file za/org-life-tickler))
#+end_src

Bind keys to those functions:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c g i") #'gtd-inbox)
  (za/global-set-key (kbd "C-c g g") #'gtd)
  (za/global-set-key (kbd "C-c g a") #'gtd-archive)
  (za/global-set-key (kbd "C-c g s") #'gtd-someday)
  (za/global-set-key (kbd "C-c g t") #'gtd-tickler)
#+end_src
**** Refiling & archiving
Where I want to be able to move subtrees (doesn't include inbox because I never refile to that, and the archive has its own keybining):

#+begin_src emacs-lisp
    (setq org-refile-targets `((,za/org-life-main :maxlevel . 3)
                               (,za/org-life-someday :level . 1)
                               (,za/org-life-tickler :maxlevel . 2)))
#+end_src

I want to archive to a specific file, in a date tree:

#+begin_src emacs-lisp
  (setq org-archive-location (concat za/org-life-archive "::datetree/"))
#+end_src

Include the destination file as an element in the path to a heading, and to use the full paths as completion targets rather than just the heading text itself:

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path 'file)
#+end_src

Tell Org that I don’t want to complete in steps; I want Org to generate all of the possible completions and present them at once (necessary for Helm/Ivy):

#+begin_src emacs-lisp
  (setq org-outline-path-complete-in-steps nil)
#+end_src

Allow me to tack new heading names onto the end of my outline path, and if I am asking to create new ones, make me confirm it:

#+begin_src emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

**** Quick capture
Quick capture lets me send something to my inbox very quickly, without thinking about where it should go.
The inbox is processed later.

Templates for quick capture:

#+begin_src emacs-lisp
  (setq org-capture-templates `(("t" "Todo [inbox]" entry
                                 (file ,za/org-life-inbox)
                                 "* TODO %i%?")

                                ("s" "Save for read/watch/listen" entry
                                 (file+headline ,za/org-life-tickler "Read/watch/listen")
                                 "* TODO %?[[%^{link}][%^{description}]] %^G")))
#+end_src

**** Todo & custom agenda views
Todo keywords based on the GTD system (pipe separates incomplete from complete).
Apart from the logging-on-done configured [[*Logging][below]], I also want to log a note & timestamp when I start waiting on something.
In ~org-todo-keywords~, ~@~ means note+timestamp, ~!~ means timestamp, ~@/!~ means note+timestamp on state entry and timestamp on leave.

#+begin_src emacs-lisp
  (setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w@)" "STARTED(s)" "|" "DONE(d)" "CANCELLED(c)"))
        org-todo-keyword-faces '(("TODO" . org-todo)
                                 ("NEXT" . org-todo)
                                 ("WAITING" . org-todo)
                                 ("STARTED" . org-todo)
                                 ("DONE" . org-done)
                                 ("CANCELLED" . org-done)))
#+end_src

I decided that projects will not be TODO items, but their progress will be tracked with a progress cookie ([x/y]). This function converts an item to a project: it adds a PROJECT tag, sets the progress indicator to count all checkboxes in sub-items (only TODO items), and removes any existing TODO keywords. Finally, PROJECT tags shouldn't be inherited (i.e. subtasks shouldn't be marked as projects).

#+begin_src emacs-lisp
  (defun za/mark-as-project ()
    "This function makes sure that the current heading has
      (1) the tag PROJECT
      (2) the property COOKIE_DATA set to \"todo recursive\"
      (3) a leading progress indicator"
    (interactive)
    (org-set-property "TODO" "")
    (org-toggle-tag "PROJECT" 'on)
    (org-set-property "COOKIE_DATA" "todo recursive")
    (org-back-to-heading t)
    (forward-whitespace 1)
    (insert "[/] ")
    (org-update-statistics-cookies nil))
#+end_src

Only the top-level project headlines should be tagged as projects, so disable inheritance of that tag:

#+begin_src emacs-lisp
  (setq org-tags-exclude-from-inheritance '("PROJECT"))
#+end_src

Define a function to skip items if they're part of a project (i.e. one of their parents has a "PROJECT" tag).
The problem is, the "PROJECT" tag isn't inherited. So, we temporarily disable excluding from inheritance, just for the ~org-get-tags~ call. Then check if "PROJECT" is one of the tags.

#+begin_src emacs-lisp
  (defun za/skip-if-in-project ()
    "Skip items that are part of a project"
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (item-tags (let ((org-tags-exclude-from-inheritance nil)) (org-get-tags))))
      (if (member "PROJECT" item-tags)
          subtree-end
        nil)))

#+end_src

Also, define a function to skip tasks (trees) that are not habits (i.e. don't have the STYLE property ~habit~):

#+begin_src emacs-lisp
  (defun za/skip-unless-habit ()
    "Skip trees that are not habits"
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          nil
        subtree-end)))
#+end_src

And one to skip tasks that /are/ habits:

#+begin_src emacs-lisp
  (defun za/skip-if-habit ()
    "Skip trees that are not habits"
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))
#+end_src


And another function, to skip tasks that are blocked:

#+begin_src emacs-lisp
  (defun za/skip-if-blocked ()
    "Skip trees that are blocked by previous tasks"
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (org-entry-blocked-p)
          subtree-end
        nil)))
#+end_src

Create custom agenda view based on those keywords.
Agenda views are made up of blocks, appearing in the order that you declare them.
The first two strings are what shows up in the agenda dispatcher (the key to press and the description).

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("n" "Next actions"
           ((todo "NEXT" ((org-agenda-overriding-header "Next actions:")))))
          ("W" "Waiting"
           ((todo "WAITING" ((org-agenda-overriding-header "Waiting:")))))
          ("S" . "Saved for later...")
          ("Sw" "Saved to watch"
           ((tags-todo "WATCH" ((org-agenda-overriding-header "To watch:")))))
          ("Sr" "Saved to read"
           ((tags-todo "READ" ((org-agenda-overriding-header "To read:")))))
          ("Sl" "Saved to listen"
           ((tags-todo "LISTEN" ((org-agenda-overriding-header "To listen:")))))

          ("a" . "Agenda with schedule only...")
          ("aw" "This week"
           ((agenda "" ((org-agenda-span 'week)))))
          ("ad" "Today"
           ((agenda "" ((org-agenda-span 'day)))))
          ("at" "Tomorrow"
           ((agenda "" ((org-agenda-span 'day)
                        (org-agenda-start-day "+1d")))))

          ("w" "Week Agenda + Next Actions"
           ((agenda "" ((org-agenda-overriding-header "Week agenda:")))
            (todo "NEXT" ((org-agenda-overriding-header "Next actions:")))))

          ("o" "Month agenda"
           ((agenda "" ((org-agenda-overriding-header "Month agenda:")
                        (org-agenda-span 'month)))))

          ("d" "Day Agenda + Next Actions + Habits"
           ((agenda "" ((org-agenda-overriding-header "Day:")
                        (org-agenda-span 'day)
                        (org-habit-show-habits nil)))
            (todo "NEXT" ((org-agenda-overriding-header "Next actions:")))
            (agenda "" ((org-agenda-overriding-header "Habits:")
                        (org-agenda-span 'day)
                        (org-agenda-use-time-grid nil)
                        (org-agenda-skip-function 'za/skip-unless-habit)
                        (org-habit-show-habits t) (org-habit-show-habits-only-for-today nil)
                        (org-habit-show-all-today t)))
            (todo "WAITING" ((org-agenda-overriding-header "Waiting:")))))

          ("p" "Projects"
           ((tags "PROJECT" ((org-agenda-overriding-header "Projects:")
                             (org-agenda-prefix-format '((tags . " %i %-22(let ((deadline (org-entry-get nil \"DEADLINE\"))) (if deadline deadline \"\"))")))
                             (org-agenda-sorting-strategy '((tags deadline-up alpha-down)))))))

          ("f" "Finished tasks that aren't in a project"
           ((tags "TODO=\"DONE\"|TODO=\"CANCELLED\"" ((org-agenda-overriding-header "Finished tasks:")
                                                      (org-agenda-skip-function 'za/skip-if-in-project)))))

          ;; Useful thread for opening calfw: https://github.com/kiwanami/emacs-calfw/issues/18
          ("c" "Calendar view" (lambda (&rest _)
                                 (interactive)
                                 (let ((org-agenda-skip-function 'za/skip-if-habit))
                                   (cfw:open-org-calendar))))))
#+end_src

In calfw, I don't want to show habits:

#+begin_src emacs-lisp
  (add-hook 'cfw:calendar-mode-hook (setq-local org-agenda-skip-function 'za/skip-if-habit))
#+end_src

**** Logging for tasks
I want to log into the LOGBOOK drawer (useful when I want to take quick notes):

#+begin_src emacs-lisp
  (setq org-log-into-drawer "LOGBOOK")
#+end_src

I also want to log when I finish a task (useful for archiving).
Furthermore, when I'm done, I want to add a note (any important
workarounds/tips). And when I reschedule, I want to know the reason.
I can disable logging on state change for a specific task by adding ~:LOGGING: nil~ to the ~:PROPERTIES:~ drawer.

#+begin_src emacs-lisp
  (setq org-log-done 'note
        org-log-reschedule 'note)
#+end_src

I want to hide drawers on startup. This variable has options:
- 'overview': Top-level headlines only.
- 'content': All headlines.
- 'showall': No folding on any entry.
- 'show2levels: Headline levels 1-2.
- 'show3levels: Headline levels 1-3.
- 'show4levels: Headline levels 1-4.
- 'show5levels: Headline levels 1-5.
- 'showeverything: Show even drawer contents.

#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

**** Task ordering
Some tasks should be ordered, i.e. they should be done in steps.
Those have the ~:ORDERED: t~ setting in ~:PROPERTIES:~, and it should be enforced:

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
#+end_src

Furthermore, tasks that are ordered and can't be done yet because of previous steps should be dimmed in the agenda:

#+begin_src emacs-lisp
  (setq org-agenda-dim-blocked-tasks t)
#+end_src

I might also want to set ~org-enforce-todo-checkbox-dependencies~, but not convinced on that one yet.

**** Time tracking & effort
Time tracking should be done in its own drawer:

#+begin_src emacs-lisp
  (setq org-clock-into-drawer "CLOCK")
#+end_src

And to customize how clock tables work:

#+begin_src emacs-lisp
  (setq org-clocktable-defaults '(:lang "en" :scope agenda-with-archives  :wstart 1 :mstart 1 :compact t :maxlevel nil))
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel nil))
#+end_src

I want to set effort in hours:minutes:

#+begin_src emacs-lisp
  (add-to-list 'org-global-properties '("Effort_ALL" . "0:05 0:10 0:15 0:20 0:30 0:45 1:00 1:30 2:00 4:00 6:00 8:00"))
#+end_src

I want column view to look like this:

| To do        | Task      | Tags | Sum of time elapsed | Sum of time estimated (effort) |
|--------------+-----------+------+---------------------+--------------------------------|
| todo keyword | task name | tags | sum of clock        | sum of estimated time          |
| ...          | ...       | ...  | ...                 | ...                            |

#+begin_src emacs-lisp
  (setq org-columns-default-format "%7TODO (To Do) %32ITEM(Task) %TAGS(Tags) %11CLOCKSUM_T(Clock) %8Effort(Effort){:}")
#+end_src

Fix column alignment in agenda.

#+begin_src emacs-lisp
  (set-face-attribute 'org-column nil
                      :height (face-attribute 'default :height)
                      :family (face-attribute 'default :family))
  (set-face-attribute 'org-agenda-date-today nil
                      :height (face-attribute 'default :height))
#+end_src

**** Calculate time since timestamp
#+begin_src emacs-lisp
  (defun za/org-time-since ()
    "Print the amount of time between the timestamp at point and the current date and time."
    (interactive)
    (unless (org-at-timestamp-p 'lax)
      (user-error "Not at timestamp"))

    (when (org-at-timestamp-p 'lax)
      (let ((timestamp (match-string 0)))
        (with-temp-buffer
          (insert timestamp
                  "--"
                  (org-time-stamp '(16)))
          (org-evaluate-time-range)))))
#+end_src

*** Custom functions
**** Get number of headlines in a file
#+begin_src emacs-lisp
  (defun za/org-count-headlines-in-file (level filename)
    "Count number of level LEVEL headlines in FILENAME. If LEVEL is 0, count all."
    (let ((headline-str (cond ((zerop level) "^\*+")
			      (t (format "^%s " (apply 'concat (make-list level "\\*")))))))
      (save-mark-and-excursion
	(with-temp-buffer
	  (insert-file-contents filename)
	  (count-matches headline-str (point-min) (point-max))))))
#+end_src

**** Yank URL
#+begin_src emacs-lisp
  (defun org-yank-link-url ()
    (interactive)
    (kill-new (org-element-property :raw-link (org-element-context)))
    (message "Link copied to clipboard"))
#+end_src
**** Manipulating time
Sometimes I want to be able to close a TODO at a different time than /right now/.
So we'll have a buffer-local variable that controls whether we use /right now/ (if nil), or some other time (if set).

***** The variable that controls it
#+begin_src emacs-lisp
  (defvar-local za/org-current-time-effective nil)
#+end_src

And a function to manipulate the variable:

#+begin_src emacs-lisp
  (defun za/set-org-current-time-effective ()
    "Set `current-time' in the current buffer for `org-todo'.
  Use `keyboard-quit' to unset it."
    (interactive)
    (setq za/org-current-time-effective
          (condition-case nil
              (org-read-date t 'totime)
            (quit nil))))
#+end_src

And a binding for that function:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c q t") #'za/set-org-current-time-effective)
#+end_src

Now we have to modify the functions that get the date.

***** Repeater in todo (e.g. .+1d)
For the repeater:

#+begin_src emacs-lisp
  (defun za/org-today-effective (old-org-today)
    (if za/org-current-time-effective
        (time-to-days za/org-current-time-effective)
      (funcall old-org-today)))

  (advice-add 'org-today :around #'za/org-today-effective)
#+end_src

***** Logging (e.g. logrepeat, with note -- the timestamp you see in the logbook)
#+begin_src emacs-lisp
  (defun za/org-current-time-effective (old-org-current-time &rest args)
    "Return the manually set effective time, or call the original function to get it."
    (or za/org-current-time-effective
        (apply old-org-current-time args)))

  (advice-add 'org-current-time :around #'za/org-current-time-effective)

#+end_src

***** last_repeat property
#+begin_src emacs-lisp
  (defun za/org-time-stamp-format-effective (old-org-time-stamp-format &rest args)
    (if za/org-current-time-effective
        (format-time-string (funcall old-org-time-stamp-format args) za/org-current-time-effective)
      (apply old-org-time-stamp-format args)))
  (advice-add 'org-time-stamp-format :around #'za/org-time-stamp-format-effective)
#+end_src

*** Tempo expansions

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sb" . "src bibtex"))
  (add-to-list 'org-structure-template-alist '("ss" . "src sh"))
#+end_src

*** Catch invisible edits
Sometimes when text is folded away, I might accidentally edit text inside of it.
This option prevents that.
I wanted to do 'smart', but that has a 'fixme' so it might change in the future...
Instead, show what's being edited, but don't perform the edit.

#+begin_src emacs-lisp
  (setq org-catch-invisible-edits 'show-and-error)
#+end_src

*** Notification
macOS doesn't have dbus. So I use terminal-notifier for functions like org-notify:

#+begin_src emacs-lisp
  (if (and (eq system-type 'darwin)
           (executable-find "terminal-notifier"))
      (setq org-show-notification-handler
            (lambda (str) (start-process "terminal-notifier" nil (executable-find "terminal-notifier")
                                         "-title" "Timer done"
                                         "-message" str
                                         "-group" "org.gnu.Emacs"
                                         "-sender" "org.gnu.Emacs"))))
#+end_src

*** org-caldav
This lets me sync my Org agenda to my CalDAV server.
The main reason is because Orgzly doesn't have a calendar view and can't (yet) search for events on a specific day, so if someone asks "are you free on that day", it's a bit hard for me to answer if I don't have my computer with me.
This way, I can just check my calendar.

#+begin_src emacs-lisp
  (use-package org-caldav)
#+end_src

A lot of these variables are from my secret.el file, they're not something I can share publicly.
I use ~/.authinfo.gpg to store authorization info for the server.

#+begin_src emacs-lisp
  (setq org-caldav-url za/caldav-url
        org-caldav-calendar-id za/caldav-org-calendar-id
        za/org-life-calendar-inbox (concat za/org-life-dir "calendar-inbox.org")
        org-caldav-inbox za/org-life-calendar-inbox
        org-caldav-files (cons (car (split-string org-archive-location "::")) org-agenda-files)
        org-icalendar-include-todo 'all
        org-icalendar-use-deadline '(event-if-todo event-if-not-todo todo-due)
        org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))

#+end_src

I don't want to export habits, because those will just clutter up my calendar.
The calendar is supposed to be for one-off stuff, or rarely repeating stuff.
Yes, I have to manually add the "HABIT" tag to every habit.
Perhaps nicer would be to exclude based on the property ~:STYLE: habit~, but I haven't figured that one out yet.

#+begin_src emacs-lisp
  (setq org-caldav-exclude-tags '("HABIT"))
#+end_src

Maybe check [[https://old.reddit.com/r/orgmode/comments/8rl8ep/making_orgcaldav_useable/e0sb5j0/][this]] for a way to sync on save.
** org-contrib
#+begin_src emacs-lisp
  (use-package org-contrib
    :config
    (require 'org-checklist))
#+end_src
** org-ref
#+begin_src emacs-lisp
  (use-package org-ref)
#+end_src
** org-roam
#+begin_src emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-directory za/org-roam-dir)
    (org-roam-completion-everywhere t)

    :config
    (org-roam-setup))
  (require 'org-roam-export)
#+end_src

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c w n") #'org-roam-capture)
  (za/global-set-key (kbd "C-c w f") #'org-roam-node-find)
  (za/global-set-key (kbd "C-c w w") #'org-roam-buffer-toggle)
  (za/global-set-key (kbd "C-c w i") #'org-roam-node-insert)
#+end_src
** org-roam-ui
#+begin_src emacs-lisp
  (use-package org-roam-ui)
#+end_src
** org publishing
I decided, after trying many different thing, to settle on org-publish.
Markdown export didn't let me add a preamble, which Zola requires; there's no proper backend for Zola.
So I settled on HTML export.
The ~:html-head~ setting comes from my base template for the website.

#+begin_src emacs-lisp
  (require 'ox-publish)
  (setq org-publish-project-alist
        `(
          ("org-roam" :components ("org-notes" "org-notes-data"))
          ("org-notes"
           :base-directory ,za/org-roam-dir
           :base-extension "org"
           :publishing-directory ,(concat za/my-website-dir "static/org-roam/")
           :recursive t
           :publishing-function org-html-publish-to-html
           :auto-preamble t
           :sitemap-filename "index.org"
           :sitemap-title "Org Roam"
           :auto-sitemap t
           :html-head "
        <script type=\"text/javascript\">
        if (window.matchMedia('(prefers-color-scheme: dark)').media === 'not all') {
          document.documentElement.style.display = 'none';
          var hour = new Date().getHours();
          var sheet = (hour >= 20 || hour < 6) ? \"/dark.css\" : \"/light.css\";
          document.head.insertAdjacentHTML(
            'beforeend',
            '<link rel=\"stylesheet\" type=\"text/css\" href=\"'+sheet+'\" onload=\"document.documentElement.style.display = \'\'\">'
          );
        }
      </script>
      <!-- For browsers without JS, load the light theme -->
      <noscript><link rel=\"stylesheet\" type=\"text/css\" href=\"/light.css\"></noscript>
      <!-- For browsers supporting prefers-color-scheme, use that -->
      <link rel=\"stylesheet\" type=\"text/css\" href=\"/dark.css\" media=\"(prefers-color-scheme: dark)\">
      <link rel=\"stylesheet\" type=\"text/css\" href=\"/light.css\" media=\"(prefers-color-scheme: light)\">

      <!-- PWA stuff -->
      <link rel=\"manifest\" href=\"/manifest.json\">
      <script src=\"/sw.js\"></script>
      <script>
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/sw.js')
            .then(function(registration) {
              console.log('Registration successful, scope is:', registration.scope);
            })
            .catch(function(error) {
              console.log('Service worker registration failed, error:', error);
            });
        }
      </script>
  "
           )
          ("org-notes-data"
           :base-directory ,za/org-roam-dir
           :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
           :publishing-directory ,(concat za/my-website-dir "static/org-roam/")
           :recursive t
           :publishing-function org-publish-attachment)
          ))
#+end_src

** calfw
Basically provides a way to show the org agenda as a standard GUI calendar app would.

#+begin_src emacs-lisp
  (use-package calfw
    :config
    (use-package calfw-org)
    (setq cfw:org-overwrite-default-keybinding t)
    (setq calendar-week-start-day 1))
#+end_src

** lean-mode
Specifically for the Lean prover.
I also install company-lean and helm-lean, which are suggested on the [[https://github.com/leanprover/lean-mode][Github page]].
Then I map company-complete only for lean-mode.

#+begin_src emacs-lisp
  (use-package lean-mode
    :config
    (use-package company-lean)
    :hook
    (lean-mode . (lambda () )))
#+end_src

#+begin_src emacs-lisp
  (defun za/keybinds-lean-mode ()
    "Function to set lean-mode keybindings, run via lean-mode-hook."
    (define-key lean-mode-map (kbd "S-SPC") #'company-complete))

  (add-hook 'lean-mode-hook #'za/keybinds-lean-mode)
#+end_src

** magit
#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** vterm
Emacs has a bunch of built-in terminal emulators.
And they all suck.
(OK not really, eshell is alright, but not for interactive terminal programs like newsboat/neomutt)

Also use emacsclient inside vterm as an editor, because that'll open documents in the existing Emacs session.
And I'm not gonna be a heretic and open Vim inside of Emacs.

#+begin_src emacs-lisp
  (use-package vterm
    :hook
    (vterm-mode . (lambda () (unless server-process (server-start)))))
#+end_src

I'll bind a key to start a vterm or switch to the running vterm:

#+begin_src emacs-lisp
  (defun switch-to-vterm () "Switch to a running vterm, or start one and switch to it."
         (interactive)
         (if (get-buffer vterm-buffer-name)
             (switch-to-buffer vterm-buffer-name)
           (vterm)))
  (za/global-set-key (kbd "C-c t") 'switch-to-vterm)
#+end_src

** sr-speedbar
Make speed bar show in the current frame.

#+begin_src emacs-lisp
  (use-package sr-speedbar
    :config
    (setq sr-speedbar-right-side nil))
#+end_src

#+begin_src emacs-lisp
  (defun za/keybinds-speedbar-mode ()
    "Function to set speedbar-mode keybindings, run via speedbar-mode-hook."
    (define-key speedbar-mode-map (kbd "q") 'sr-speedbar-close))

  (add-hook 'speedbar-mode-hook #'za/keybinds-speedbar-mode)
#+end_src

Jump to speedbar. sr-speedbar-exist-p can be void, so I check if it's bound first.
If it's not bound, or if it's false, first open the speedbar.
Then, select it.

#+begin_src emacs-lisp
  (defun za/jump-to-speedbar-or-open ()
    "Open a speedbar or jump to it if already open."
    (interactive)
    (if (or (not (boundp 'sr-speedbar-exist-p))
            (not (sr-speedbar-exist-p)))
        (sr-speedbar-open))
    (sr-speedbar-select-window))
#+end_src



#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c F") 'za/jump-to-speedbar-or-open)
#+end_src
** expand-region
Expand the selected region semantically.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

** flycheck
Install flycheck, and enable it by default in certain major modes:

#+begin_src emacs-lisp
  (use-package flycheck
    :hook (sh-mode . flycheck-mode))
#+end_src

** anki-editor
Some extra keybindings that are not set up by default.
anki-editor doesn't provide a keymap so I have to set one up here:

#+begin_src emacs-lisp
  (use-package anki-editor
    :config
    (defvar anki-editor-mode-map (make-sparse-keymap))
    (add-to-list 'minor-mode-map-alist (cons 'anki-editor-mode
                                             anki-editor-mode-map))

    (setq anki-editor-use-math-jax t)

    :hook
    (anki-editor-mode . (lambda ()
                          (define-key anki-editor-mode-map (kbd "C-c t") #'org-property-next-allowed-value)
                          (define-key anki-editor-mode-map (kbd "C-c i") #'anki-editor-insert-note)
                          (define-key anki-editor-mode-map (kbd "C-c p") #'anki-editor-push-notes)
                          (define-key anki-editor-mode-map (kbd "C-c c") #'anki-editor-cloze-dwim))))
#+end_src

** rainbow-mode
'rainbow-mode' lets you visualise hex colors:

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :hook (emacs-lisp-mode . rainbow-mode))
#+end_src

** pdf-tools
A better replacement for DocView:

#+begin_src emacs-lisp
  (use-package pdf-tools
    :config
    (setq-default pdf-annot-default-annotation-properties '((t
                                                             (label . "Alex Balgavy"))
                                                            (text
                                                             (icon . "Note")
                                                             (color . "#0088ff"))
                                                            (highlight
                                                             (color . "yellow"))
                                                            (squiggly
                                                             (color . "orange"))
                                                            (strike-out
                                                             (color . "red"))
                                                            (underline
                                                             (color . "blue"))))
    :hook
    (pdf-annot-list-mode . pdf-annot-list-follow-minor-mode)
    (pdf-annot-edit-contents-minor-mode . org-mode)
    (pdf-view-mode . (lambda () (display-line-numbers-mode 0)))
    (pdf-view-mode . (lambda () (define-key pdf-isearch-minor-mode-map (kbd "C-s") #'isearch-forward))))
  (pdf-tools-install)
#+end_src

Save position and jump back:

#+begin_src emacs-lisp
  (define-key pdf-view-mode-map (kbd "C-SPC")
    (lambda () (interactive) (message "Position saved") (pdf-view-position-to-register ?x)))
  (define-key pdf-view-mode-map (kbd "C-u C-SPC")
    (lambda () (interactive) (pdf-view-jump-to-register ?x)))
#+end_src

*** TODO this clobbers register x. Find a way to not clobber a register

** virtualenvwrapper
Like virtualenvwrapper.sh, but for Emacs.

#+begin_src emacs-lisp
  (use-package virtualenvwrapper
    :config
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    (setq venv-location "~/.config/virtualenvs"))
#+end_src

** org-noter
#+begin_src emacs-lisp
  (use-package org-noter)
#+end_src

Fix disabling of line wrap by no-opping set-notes-scroll:

#+begin_src emacs-lisp
  (defun za/no-op (&rest args))
  (advice-add 'org-noter--set-notes-scroll :override 'za/no-op)
#+end_src

** hl-todo
I want to highlight TODO keywords in comments:

#+begin_src emacs-lisp
  (use-package hl-todo
    :custom-face
    (hl-todo ((t (:inherit hl-todo :underline t))))
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#ff7060")
            ("FIXME"  . "#caa000")))
    (global-hl-todo-mode t))
#+end_src
** undo-tree
Sometimes it's better to look at undo history as a tree:

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode))
#+end_src

Save undo files into ~/.emacs.d/undo-tree

#+begin_src emacs-lisp
  (let ((undo-tree-dir (concat user-emacs-directory "undo-tree/")))
    (unless (file-directory-p undo-tree-dir) (make-directory undo-tree-dir))
    (setq undo-tree-history-directory-alist `(("." . ,undo-tree-dir))))
#+end_src

** ledger
#+begin_src emacs-lisp
  (use-package ledger-mode
    :mode ("\\.ledger\\'")
    :config
    (setq ledger-clear-whole-transactions t
          ledger-reconcile-default-commodity "eur"))
#+end_src

org-capture lets me add transactions from anywhere in Emacs:

#+begin_src emacs-lisp
    (add-to-list 'org-capture-templates `("$" "Ledger entry" plain
                                          (file ,za/ledger-file)
                                          "%(ledger-read-date \"Date\") %^{Payee}
      %^{Account}  %^{Amount}
      Assets:ABN Checking%?
    "
                                          :empty-lines-before 1))


#+end_src

Budget throws an error when there's multiple commodities involved.
See discussion here: https://github.com/ledger/ledger/issues/1450#issuecomment-390067165
#+begin_src emacs-lisp
  (setq za/ledger-budget-fix-string
      "-X eur -F '%(justify(scrub(get_at(display_total, 0)), 20, -1, true, false)) %(justify(get_at(display_total, 1) ? -scrub(get_at(display_total, 1)) : 0.0, 20,            20 + 1 + 20, true, false)) %(justify(get_at(display_total, 1) ? (get_at(display_total, 0) ?           -(scrub(get_at(display_total, 1) + get_at(display_total, 0))) :           -(scrub(get_at(display_total, 1)))) : -(scrub(get_at(display_total, 0))), 20,            20 + 1 + 20 + 1 + 20, true, false))%(get_at(display_total, 1) and (abs(quantity(scrub(get_at(display_total, 0))) /           quantity(scrub(get_at(display_total, 1)))) >= 1) ?  \" \" : \" \")%(justify((get_at(display_total, 1) ?           (100% * (get_at(display_total, 0) ? scrub(get_at(display_total, 0)) : 0.0)) /              -scrub(get_at(display_total, 1)) : \"na\"),            5, -1, true, false))  %(!options.flat ? depth_spacer : \"\")%-(partial_account(options.flat))\n%/%$2 %$3 %$4 %$6\n%/%(prepend_width ? \" \" * int(prepend_width) : \"\")    ----------------     ----------------     ---------------- -----\n'")
#+end_src
Custom reports:

#+begin_src emacs-lisp
  (custom-set-variables
   '(ledger-reports
     '(("budget-last-month" "%(binary) -f %(ledger-file) --start-of-week=1 --period \"last month\" budget ^expenses")
       ("budget-this-month" "%(binary) -f %(ledger-file) --start-of-week=1 --period \"this month\" budget ^expenses")
       ("expenses-this-month-vs-budget" "%(binary) -f %(ledger-file) --start-of-week=1 --period \"this month\" --period-sort \"(amount)\" bal ^expenses --budget")
       ("expenses-last-month-vs-budget" "%(binary) -f %(ledger-file) --start-of-week=1 --period \"last month\" --period-sort \"(amount)\" bal ^expenses --budget")
       ("expenses-this-month" "%(binary) -f %(ledger-file) --start-of-week=1 --period \"this month\" --period-sort \"(amount)\" bal ^income ^expenses -X eur")
       ("expenses-last-month" "%(binary) -f %(ledger-file) --start-of-week=1 --period \"last month\" --period-sort \"(amount)\" bal ^expenses -X eur")
       ("expenses-this-month" "%(binary) -f %(ledger-file) --start-of-week=1 --period \"this month\" --period-sort \"(amount)\" bal ^expenses -X eur")
       ("expenses-vs-income-this-month" "%(binary) -f %(ledger-file) --start-of-week=1 --effective --period \"this month\" --period-sort \"(amount)\" bal ^income ^expenses -X eur")
       ("expenses-vs-income-last-month" "%(binary) -f %(ledger-file) --start-of-week=1 --effective --period \"last month\" --period-sort \"(amount)\" bal ^expenses ^income -X eur")
       ("bal-assets-czk" "%(binary) -f %(ledger-file) --start-of-week=1 bal Assets Liabilities -X czk")
       ("bal-assets" "%(binary) -f %(ledger-file) --start-of-week=1 bal Assets Liabilities")
       ("bal" "%(binary) -f %(ledger-file) --start-of-week=1 bal -B")
       ("bal-assets-eur" "%(binary) -f %(ledger-file) --start-of-week=1 bal Assets Liabilities -X eur")
       ("monthly-balance-abn-checking" "%(binary) -f %(ledger-file) --start-of-week=1 --effective reg --monthly 'Assets:ABN Checking'")
       ("monthly-expenses" "%(binary) -f %(ledger-file) --monthly register ^expenses --collapse -X eur")
       ("reg" "%(binary) -f %(ledger-file) --start-of-week=1 reg")
       ("payee" "%(binary) -f %(ledger-file) --start-of-week=1 reg @%(payee)")
       ("account" "%(binary) -f %(ledger-file) --start-of-week=1 reg %(account)"))))
#+end_src
** osm
#+begin_src emacs-lisp
  (use-package osm
    :bind (("C-c M h" . osm-home)
           ("C-c M s" . osm-search)
           ("C-c M v" . osm-server)
           ("C-c M t" . osm-goto)
           ("C-c M x" . osm-gpx-show)
           ("C-c M j" . osm-bookmark-jump))

    :custom
    ;; Take a look at the customization group `osm' for more options.
    (osm-server 'default) ;; Configure the tile server
    (osm-copyright nil)     ;; Display the copyright information

    :init
    ;; Load Org link support
    (with-eval-after-load 'org
      (require 'osm-ol)))
#+end_src
** ess
#+begin_src emacs-lisp
  (use-package ess)
#+end_src
** eglot
A good LSP plugin.

#+begin_src emacs-lisp
  (use-package eglot)
#+end_src

** crdt
Collaborative editing in Emacs:

#+begin_src emacs-lisp
  (use-package crdt)
#+end_src

* Interface
** Start debugger on error
#+begin_src emacs-lisp
  ;; (toggle-debug-on-error t)
#+end_src

** Messages
Hide some messages I don't need, and add a list of recent files.

#+begin_src emacs-lisp
  (recentf-mode)
  (setq inhibit-startup-message t
	initial-major-mode #'org-mode
	initial-scratch-message
	(concat "Welcome to Emacs\n\n"
		"Recent:\n"
		(mapconcat
		 (lambda (x) (format "- [[%s]]" x)) recentf-list "\n")
		"\n\nELISP Evaluation area:\n#+begin_src emacs-lisp\n\n#+end_src"))

#+end_src

** Appearance
*** Cursor line
Highlight the current line:

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src
*** Matching parentheses
Don't add a delay to show matching parenthesis.
Must come before show-paren-mode enable.

#+begin_src emacs-lisp
  (setq show-paren-delay 0)
#+end_src

Show matching parentheses:

#+begin_src emacs-lisp
  (show-paren-mode t)
#+end_src

*** Cursor
The default box cursor isn't really accurate, because the cursor is actually between letters, not on a letter.
So, I want a bar instead of a box:

#+begin_src emacs-lisp
  (setq-default cursor-type '(bar . 4)
                cursor-in-non-selected-windows 'hollow)
#+end_src

(I use ~setq-default~ here because cursor-type is automatically buffer-local when it's set)

*** Line numbers
Relative line numbers:

#+begin_src emacs-lisp
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)
#+end_src

Function to hide them:

#+begin_src emacs-lisp
  (defun za/hide-line-numbers ()
    "Hide line numbers"
    (display-line-numbers-mode 0))
#+end_src
Don't display them in specific modes.  For each of the modes in
'mode-hooks', add a function to hide line numbers when the mode
activates (which triggers the 'mode'-hook).

#+begin_src emacs-lisp
  (let ((mode-hooks '(doc-view-mode-hook vterm-mode-hook mpc-status-mode-hook mpc-tagbrowser-mode-hook)))
    (mapc
     (lambda (mode-name)
       (add-hook mode-name #'za/hide-line-numbers))
     mode-hooks))
#+end_src
*** Modeline
I want to show the time and date in the modeline:

#+begin_src emacs-lisp
  (setq display-time-day-and-date t           ; also the date
        display-time-default-load-average nil ; don't show load average
        display-time-format "%I:%M%p %e %b (%a)")   ; "HR:MIN(AM/PM) day-of-month Month (Day)"
  (display-time-mode 1)                  ; enable time mode
#+end_src

And to set the modeline format:

#+begin_src emacs-lisp
  (setq-default mode-line-format '("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position
                                   (vc-mode vc-mode)
                                   "  " mode-line-modes mode-line-misc-info mode-line-end-spaces))
#+end_src

I want to hide certain modes from the modeline, they're always on:

#+begin_src emacs-lisp
  (use-package diminish
    :config
    (let ((modes-to-hide '(ivy-mode counsel-mode which-key-mode hl-todo-mode undo-tree-mode ivy-posframe-mode)))
      (mapc (lambda (mode-name) (diminish mode-name)) modes-to-hide))
    (diminish 'view-mode " 👓"))
#+end_src
*** Transparent title bar
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src
*** Tab bar
Only show tab bar if there's more than 1 tab:

#+begin_src emacs-lisp
  (setq tab-bar-show 1)
#+end_src

** Buffer displaying

So, this is a bit hard to grok. But basically the alist contains a
regular expression to match a buffer name, then a list of functions to
use in order for displaying the list, and then options for those functions (each of which is an alist).

#+begin_src emacs-lisp
  (setq
   ;; Maximum number of side-windows to create on (left top right bottom)
   window-sides-slots '(0   ;; left
                        1   ;; top
                        3   ;; right
                        1 ) ;; bottom

   display-buffer-alist '(
                          ;; Right side
                          ("\\*Help\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . -1)
                           (inhibit-same-window . t))
                          ("\\*Async Shell Command\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . 0)
                           (inhibit-same-window . t))
                          ("magit-process: .*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . 0)
                           (inhibit-same-window . t))

                          ;; Top side
                          ("\\*Info\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . top)
                           (slot . 0))
                          ("\\*Man .*\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . top)
                           (slot . 0))

                          ;; Bottom
                          ("\\*Flycheck errors\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . bottom)
                           (slot . 0))))
#+end_src

And a way to toggle those side windows:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c W") #'window-toggle-side-windows)
#+end_src
* Editor
** Overwrite selection on typing
Normally, when I select something and start typing, Emacs clears the selection, i.e. it deselects and inserts text after the cursor.
I want to replace the selection.

#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src

** Strip trailing whitespace
You can show trailing whitespace by setting show-trailing-whitespace to 't'.
But I want to automatically strip trailing whitespace.
Luckily there's already a function for that, I just need to call it in a hook:

#+begin_src emacs-lisp
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
#+end_src
** Formatting & indentation

Show a tab as 8 spaces:

#+begin_src emacs-lisp
  (setq-default tab-width 8)
#+end_src

Never insert tabs with indentation by default:

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Allow switching between the two easily:

#+begin_src emacs-lisp
  (defun indent-tabs ()
    (interactive)
    (setq indent-tabs-mode t))
  (defun indent-spaces ()
    (interactive)
    (setq indent-tabs-mode nil))
#+end_src

Indentation for various modes:

#+begin_src emacs-lisp
  (setq-default sh-basic-offset 2
                c-basic-offset 4)
#+end_src

** Wrapping

A function to toggle wrapping:

#+begin_src emacs-lisp
  (make-variable-buffer-local 'za/wrapping) ; wrapping changes per buffer

  (defun za/toggle-wrap (&optional enable)
    "Toggle line wrapping settings. With ENABLE a positive number, enable wrapping. If ENABLE is negative or zero, disable wrapping."
    (interactive "P") ; prefix arg in raw form

    ;; If an argument is provided, prefix or otherwise
    (if enable
        (let ((enable (cond ((numberp enable)
                             enable)
                            ((booleanp enable)
                             (if enable 1 0))
                            ((or (listp enable) (string= "-" enable))
                             (prefix-numeric-value enable)))))
          ;; If zero or negative, we want to disable wrapping, so pretend it's currently enabled.
          ;; And vice versa.
          (cond ((<= enable 0) (setq za/wrapping t))
                ((> enable 0) (setq za/wrapping nil)))))


    (let ((disable-wrapping (lambda ()
                              (visual-line-mode -1)
                              (toggle-truncate-lines t)))
          (enable-wrapping (lambda ()
                             (toggle-truncate-lines -1)
                             (visual-line-mode))))

      ;; If za/wrapping is not locally set, infer its values from the enabled modes
      (unless (boundp 'za/wrapping)
        (setq za/wrapping (and visual-line-mode
                               (not truncate-lines))))

      ;; Toggle wrapping based on current value
      (cond (za/wrapping
             (funcall disable-wrapping)
             (setq za/wrapping nil)
             (message "Wrapping disabled."))
            (t
             (funcall enable-wrapping)
             (setq za/wrapping t)
             (message "Wrapping enabled.")))))
#+end_src

And a keybinding to toggle wrapping:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c q w") #'za/toggle-wrap)
#+end_src

I want to wrap text at window boundary for some modes:

#+begin_src emacs-lisp
  (defun za/settings-help-mode ()
    "Help mode settings"
    (za/toggle-wrap t))
#+end_src

#+begin_src emacs-lisp
  (add-hook 'help-mode-hook #'za/settings-help-mode)
#+end_src

** Pulse line
When you switch windows, Emacs can flash the cursor briefly to guide your eyes; I like that.
Set some options for pulsing:

#+begin_src emacs-lisp
  (setq pulse-iterations 10)
  (setq pulse-delay 0.05)
#+end_src

Define the pulse function:

#+begin_src emacs-lisp
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))
#+end_src

Run it in certain cases: scrolling up/down, recentering, switching windows.
'dolist' binds 'command' to each value in the list in turn, and runs the body.
'advice-add' makes the pulse-line function run after 'command'.

#+begin_src emacs-lisp
  (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
    (advice-add command :after #'pulse-line))
#+end_src

And set the pulse color:

#+begin_src emacs-lisp
  (custom-set-faces '(pulse-highlight-start-face ((t (:background "CadetBlue2")))))
#+end_src

** Pager toggle keybinding
M-x view-mode enables pager behavior.
I want read-only files to automatically use pager mode:

#+begin_src emacs-lisp
  (setq view-read-only t)
#+end_src
** Mail mode for neomutt
When editing a message from neomutt, I want to use mail mode.
Even though I won't be sending the email from there, I like the syntax highlighting :)

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("/neomutt-" . mail-mode))
#+end_src
** Zap up to char
It's more useful for me to be able to delete up to a character instead of to and including a character:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "M-z") 'zap-up-to-char)
#+end_src
** Expansion/completion
Use hippie expand instead of dabbrev-expand:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

** Prefer newer file loading
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

** Automatically find tags file
When opening a file in a git repo, try to discover the etags file:

#+begin_src emacs-lisp
  (defun current-tags-file ()
    "Get current tags file"
    (let* ((tagspath ".git/etags")
           (git-root (locate-dominating-file (buffer-file-name) tagspath)))
      (if git-root
          (expand-file-name tagspath git-root))))

  (setq default-tags-table-function #'current-tags-file)
#+end_src

There's probably a better way to write this. I need to ask Reddit for feedback at some point.

** Semantic mode
Set default submodes:

#+begin_src emacs-lisp
  (setq semantic-default-submodes '(global-semantic-idle-scheduler-mode ; reparse buffer when idle
                                    global-semanticdb-minor-mode ; maintain database
                                    global-semantic-idle-summary-mode)) ; show information (e.g. types) about tag at point
  ;; global-semantic-stickyfunc-mode)) ; show current func in header line
#+end_src

Add some keybindings:

#+begin_src emacs-lisp
  (with-eval-after-load 'semantic
    (define-key semantic-mode-map (kbd "C-c , .") #'semantic-ia-show-summary))
#+end_src

SemanticDB is written into ~/.emacs.d/semanticdb/.

Enable semantic mode for major modes:

#+begin_src emacs-lisp
  (defun za/settings-c-mode ()
    "C mode settings"
    (semantic-mode 1))
#+end_src
#+begin_src emacs-lisp
  (let ((mode-hooks [c-mode-common-hook]))
    (mapc (lambda (mode-name)
            (add-hook mode-name #'za/settings-c-mode))
          mode-hooks))
#+end_src

** Forward-word and forward-to-word
Change M-f to stop at the start of the word:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "M-f") 'forward-to-word)
#+end_src

Bind C-M-S-F to the old functionality of M-f (stop at end of word)

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-M-S-F") 'forward-word)
#+end_src

** Rectangle insert string
#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-x r I") 'string-insert-rectangle)
  (za/global-set-key (kbd "C-x r R") 'replace-rectangle)
#+end_src
** End sentences with one space
Emacs uses the rather old-fashioned convention of treating a period followed by double spaces as end of sentence. However, it is more common these days to end sentences with a period followed by a single space.

Let a period followed by a single space be treated as end of sentence:

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src
** Make region readonly or writable
#+begin_src emacs-lisp
  (defun za/set-region-read-only (begin end)
    "Sets the read-only text property on the marked region.
  Use `set-region-writeable' to remove this property."
    ;; See https://stackoverflow.com/questions/7410125
    (interactive "r")
    (with-silent-modifications
      (put-text-property begin end 'read-only t)))

  (defun za/set-region-writeable (begin end)
    "Removes the read-only text property from the marked region.
  Use `set-region-read-only' to set this property."
    ;; See https://stackoverflow.com/questions/7410125
    (interactive "r")
    (with-silent-modifications
      (remove-text-properties begin end '(read-only t))))
#+end_src

* Markdown
Markdown mode settings.

#+begin_src emacs-lisp
  (defun za/settings-markdown-mode ()
    "My settings for markdown mode"
    (auto-fill-mode 0)
    (flyspell-mode 1)
    (za/toggle-wrap t))

  (add-hook 'markdown-mode-hook #'za-settings-markdown-mode)
#+end_src

* Bib(la)tex
#+begin_src emacs-lisp
  (defun za/settings-bibtex-mode ()
    "My settings for bibtex mode"
    (bibtex-set-dialect "biblatex"))
#+end_src

#+begin_src emacs-lisp
  (add-hook 'bibtex-mode-hook #'za/settings-bibtex-mode)
#+end_src

* Python
In Python, I want to enable flycheck and semantic mode:

#+begin_src emacs-lisp
  (add-hook 'python-mode-hook #'flycheck-mode)
  (add-hook 'python-mode-hook #'semantic-mode)
#+end_src

* Misc settings
** Enable all commands
By default, Emacs disables some commands.
I want to have these enabled so I don't get a prompt whenever I try to use a disabled command.

#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

** More extensive apropos
#+begin_src emacs-lisp
  (setq apropos-do-all t)
#+end_src
** Easily edit my config
Bind a keyboard shortcut to open my config.
The "(interactive)" means that it can be called from a keybinding or from M-x.

#+begin_src emacs-lisp
  (defun za/edit-config-org ()
    "Edit my config.org file"
    (interactive)
    (find-file (expand-file-name "config.org" user-emacs-directory)))
#+end_src

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c E") 'za/edit-config-org)
#+end_src
(describe-key (kbd "C-c E"))
** Fast access to view-mode (pager)
I want to bind view-mode to a key for easy access:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c q r") 'view-mode)
#+end_src

** Kill this buffer
I like to be able to kill a buffer instantly:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "s-<backspace>") 'kill-current-buffer)
#+end_src

** Toggle fullscreen
I'll use the keybinding that's standard on macOS:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-s-f") #'toggle-frame-fullscreen)
#+end_src

** Enable recursive minibuffers
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t
        minibuffer-depth-indicate-mode t)
#+end_src

** Sexp manipulation
When I write lisp, sometimes I want to switch two sexps (e.g. ~(one) (two)~ → ~(two) (one)~), so a key binding is nice for that:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-S-t") #'transpose-sexps)
#+end_src

Also, to raise a sexp (e.g. ~(one (two))~ → ~(two)~):

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-S-u") #'raise-sexp)
#+end_src

** Dedicated windows
Sometimes I want to avoid Emacs overriding a window's contents.
So I create a keybinding to toggle dedicated on a window:

#+begin_src emacs-lisp
  (defun za/toggle-window-dedicated-p ()
    "Toggle set-window-dedicated-p on current window"
    (interactive)
    (cond ((window-dedicated-p (selected-window))
           (set-window-dedicated-p (selected-window) nil)
           (message "Window no longer dedicated"))
          (t
           (set-window-dedicated-p (selected-window) t)
           (message "Window marked as dedicated"))))

  (za/global-set-key (kbd "C-x 9") #'za/toggle-window-dedicated-p)

#+end_src

** Rebuild org cache
#+begin_src emacs-lisp
(defun za/force-org-rebuild-cache ()
  "Rebuild the `org-mode' and `org-roam' cache."
  (interactive)
  (org-id-update-id-locations)
  ;; Note: you may need `org-roam-db-clear-all'
  ;; followed by `org-roam-db-sync'
  (org-roam-db-sync)
  (org-roam-update-org-id-locations))
#+end_src

* Daemon
I want to have a way to kill the Emacs daemon.
So, define a function that kills the frame, and with a prefix kills emacs.

#+begin_src emacs-lisp
  (defun za/emacsclient-c-x-c-c (&optional arg)
    "If running in emacsclient, make C-x C-c exit frame, and C-u C-x C-c exit Emacs."
    (interactive "P") ; prefix arg in raw form
    (if arg
        (save-buffers-kill-emacs)
      (save-buffers-kill-terminal)))
#+end_src

Then, if I'm in an emacsclient, I want to bind C-x C-c to that function (if not, I just want the default keybinding):

#+begin_src emacs-lisp
  ;; If not running in emacsclient, use the default bindings
  (if (daemonp)
      (za/global-set-key (kbd "C-x C-c") #'za/emacsclient-c-x-c-c))
#+end_src

Furthermore, I want to set the theme correctly whenever I connect with 'emacsclient':

#+begin_src emacs-lisp
  (if (daemonp)
    (add-hook 'after-make-frame-functions #'za/auto-select-theme))
#+end_src
* Notmuch
Define some saved searches (i.e. mailboxes):

#+begin_src emacs-lisp
  (setq notmuch-saved-searches
        `((:name "inbox: personal" :query ,(format "folder:/%s/ tag:inbox" za/email-personal) :key ,(kbd "ip") :search-type 'tree)
          (:name "inbox: school" :query ,(format "folder:/%s/ tag:inbox" za/email-vu) :key ,(kbd "is") :search-type 'tree)
          (:name "archive: personal" :query ,(format "folder:/%s/ tag:archive" za/email-personal) :key ,(kbd "ap") :search-type 'tree)
          (:name "archive: school" :query ,(format "folder:/%s/ tag:archive" za/email-vu) :key ,(kbd "as") :search-type 'tree)))
#+end_src

Define the main screen sections:

#+begin_src emacs-lisp
  (setq notmuch-hello-sections
        '(notmuch-hello-insert-header
          notmuch-hello-insert-saved-searches
          notmuch-hello-insert-search
          notmuch-hello-insert-alltags
          notmuch-hello-insert-footer))
#+end_src

Global keybindings:

#+begin_src emacs-lisp
  (za/global-set-key (kbd "C-c m") #'notmuch)
#+end_src

Show newest mail first:

#+begin_src emacs-lisp
  (setq notmuch-search-oldest-first nil)
#+end_src

Set tags:

#+begin_src emacs-lisp
  (setq notmuch-archive-tags '("-inbox" "+archive"))
  (setq notmuch-show-mark-unread-tags '("+unread"))
  (setq notmuch-delete-tags '("-inbox" "+trash"))

  (setq notmuch-tagging-keys '(("a" notmuch-archive-tags "Archive")
                               ("r" notmuch-show-mark-read-tags "Mark read")
                               ("u" notmuch-show-mark-unread-tags "Mark unread")
                               ("d" notmuch-delete-tags "Delete")))
#+end_src

Run notmuch-hook script on hello refresh, to move messages to folders according to their tags:

#+begin_src emacs-lisp
  (defun za/notmuch-hook-tags2folders ()
    "Run notmuch-hook to organise email in folders based on tags."
    (start-process "notmuch-hook" nil "notmuch-hook" "tags2folders"))
#+end_src

#+begin_src emacs-lisp
  (add-hook 'notmuch-hello-refresh-hook #'za/notmuch-hook-tags2folders)
#+end_src

Sort with newest first:

#+begin_src emacs-lisp
  (setq-default notmuch-search-oldest-first nil)
#+end_src

* MPC
Set the windows I want to show:

#+begin_src emacs-lisp
  (setq mpc-browser-tags '(AlbumArtist Album Genre Playlist))
#+end_src

Define some functions:

#+begin_src emacs-lisp
  (defun za/mpc-seek-forward-20-seconds ()
    "Seek forward 20 seconds"
    (interactive)
    (mpc-seek-current "+20"))

  (defun za/mpc-seek-backward-20-seconds ()
    "Seek backward 20 seconds"
    (interactive)
    (mpc-seek-current "-20"))
#+end_src

Define some keybindings:

#+begin_src emacs-lisp
  (defun za/mpc-mode-settings ()
    "MPC mode settings"
    (define-key mpc-mode-map "a" #'mpc-playlist-add)
    (define-key mpc-mode-map "P" #'mpc-playlist)
    (define-key mpc-mode-map "x" #'mpc-playlist-delete)
    (define-key mpc-mode-map "p" #'mpc-toggle-play)
    (define-key mpc-mode-map "t" #'mpc-select-toggle)
    (define-key mpc-mode-map "f" #'za/mpc-seek-forward-20-seconds)
    (define-key mpc-mode-map "b" #'za/mpc-seek-backward-20-seconds))
#+end_src

#+begin_src emacs-lisp
  (add-hook 'mpc-mode-hook #'za/mpc-mode-settings)
#+end_src

Unfortunately the lambda keybindings don't show up documented properly, but oh well. That's a minor problem.

* Radio
Just a wrapper function to my radio script:

#+begin_src emacs-lisp
  (defun radio ()
    "Play an internet radio"
    (interactive)
    (ansi-term "radio" "*radio*"))
#+end_src

* Dired
'i' expands subdirs, so I want to be able to close them too.

#+begin_src emacs-lisp
  (define-key dired-mode-map (kbd "M-k") #'dired-kill-subdir)
#+end_src

Set up listing display:

#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-alhv")
#+end_src

By default, hide details (show again by pressing oparen):

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
#+end_src

If I have another dired window open, use that as target:

#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src

* Syncthing
Some functions to start/stop syncthing.
#+begin_src emacs-lisp
  (setq za/st-buffer-name "*syncthing*")
  (defun za/st ()
    "Start syncthing"
    (interactive)
    (if (get-buffer-process za/st-buffer-name)
        (user-error "Syncthing is already running."))
    (async-shell-command "syncthing serve --no-browser" za/st-buffer-name))

  (defun za/st-kill ()
    "Stop syncthing"
    (interactive)
    (unless (get-buffer-process za/st-buffer-name)
      (user-error "Syncthing is not running."))
    (async-shell-command "syncthing cli operations shutdown"))
#+end_src

* References
Here's a list of good articles I encountered about configging emacs:
- [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]]
- [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with emacs]]

For Org mode, [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][Rainer König's tutorials]] are the best.
[[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][Here's a good reference for setting up gtd in org mode]]
