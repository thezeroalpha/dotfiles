* Theme
  I want this to load first because otherwise it'll blind me during the night while it's trying to refresh packages.

  Icons required for some parts of the doom theme:

  #+begin_src emacs-lisp
    (use-package all-the-icons)
  #+end_src

  Load Doom Emacs themes:

  #+begin_src emacs-lisp
    (use-package doom-themes
      :config
      ;; Global settings (defaults)
      (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
	    doom-themes-enable-italic t) ; if nil, italics is universally disabled

      ;; Enable flashing mode-line on errors
      (doom-themes-visual-bell-config)

      ;; Enable custom neotree theme (all-the-icons must be installed!)
      (doom-themes-neotree-config)
      ;; or for treemacs users
      (setq doom-themes-treemacs-theme "doom-colors") ; use the colorful treemacs theme
      (doom-themes-treemacs-config)

      ;; Corrects (and improves) org-mode's native fontification.
      (doom-themes-org-config))
  #+end_src

  Define the themes I want:

  #+begin_src emacs-lisp
    (setq dark-theme 'doom-one)
    (setq light-theme 'doom-acario-light)
  #+end_src

  Change theme depending on the current system theme.
  The way I check for dark mode is defined in 'dark-mode-p'; currently I use the presence of the ~/.config/dark-theme file to indicate when dark theme is set.
  A function ending in '-p' is a predicate, i.e. returns true or false.
  If calling a function that's in a variable, you have to use 'funcall'.

  #+begin_src emacs-lisp
    (let ((dark-mode-p (lambda () (file-exists-p "~/.config/dark-theme"))))
      (if (funcall dark-mode-p)
	  (load-theme dark-theme t)
	(load-theme light-theme t)))
  #+end_src

* Garbage collection
  Garbage-collect on focus-out, Emacs /should/ feel snappier.

  #+begin_src emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
  #+end_src

* Package management
** Repositories (MELPA & Org)
   #+begin_src emacs-lisp
     (require 'package)
     (add-to-list 'package-archives
		  '("melpa" . "https://melpa.org/packages/"))
     (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
     (package-refresh-contents)
     (package-initialize)
   #+end_src

** use-package
   Install and load use-package.
   Use-package tidies up package configuration and reduces the verboseness of configuration.

   #+begin_src emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-install 'use-package))
     (eval-when-compile (require 'use-package))
   #+end_src

   Always auto-install packages:

   #+begin_src emacs-lisp
     (require 'use-package-ensure)
     (setq use-package-always-ensure t)
   #+end_src

* Packages
** exec-path-from-shell (macOS)

   In macOS, the path is not set correctly in the GUI app. This fixes it.
   #+begin_src emacs-lisp
     (when (memq window-system '(mac ns x))
       (use-package exec-path-from-shell
         :config
         (add-to-list 'exec-path-from-shell-variables "NOTMUCH_CONFIG")
         (exec-path-from-shell-initialize)))
   #+end_src

** emacs-which-key
   Minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config
       (which-key-mode))
   #+end_src

** helm
   Better incremental completion and selection narrowing.
   And a bunch more.
   Generally makes for nicer interactivity, like ido mode on steroids.

   #+begin_src emacs-lisp
     (use-package helm
       :defer nil
       :custom
       (helm-M-x-always-save-history t)
       (helm-display-function 'pop-to-buffer)
       (savehist-additional-variables '(extended-command-history))
       (history-delete-duplicates t)
       :custom-face
       (helm-non-file-buffer ((t (:inherit font-lock-comment-face))))
       (helm-ff-file-extension ((t (:inherit default))))
       (helm-buffer-file ((t (:inherit default))))
       :bind
       (("M-x" . helm-M-x)
        ("C-x C-f" . helm-find-files)
        ("C-x C-b" . helm-buffers-list)
        ("C-x b" . helm-buffers-list)
        ("C-x C-r" . helm-recentf)
        ("C-x C-i" . helm-imenu)
        ("M-y" . helm-show-kill-ring))
       :config
       (helm-mode)
       (savehist-mode))
   #+end_src

** org
   In org mode, I want to use bullets instead of stars.
   Also, I add a few expansions

   #+begin_src emacs-lisp
     (use-package org
       :config
       (unless (package-installed-p 'org-bullets)
	 (package-refresh-contents)
	 (package-install 'org-bullets))
       (require 'org-bullets)
       (require 'org-tempo)

       :hook
       (org-mode . (lambda () (org-bullets-mode 1))))
   #+end_src

** lean-mode
   Specifically for the Lean prover.
   I also install company-lean and helm-lean, which are suggested on the [[https://github.com/leanprover/lean-mode][Github page]].
   Then I map company-complete only for lean-mode.

   #+begin_src emacs-lisp
     (use-package lean-mode
       :config
       (unless (package-installed-p 'company-lean)
	 (package-refresh-contents)
	 (package-install 'company-lean))
       (require 'company-lean)
       (unless (package-installed-p 'helm-lean)
	 (package-refresh-contents)
	 (package-install 'helm-lean))
       (require 'helm-lean)

       :hook
       (lean-mode . (lambda () (define-key lean-mode-map (kbd "S-SPC") #'company-complete))))
   #+end_src

** magit
   #+begin_src emacs-lisp
     (use-package magit)
   #+end_src

** vterm
Emacs has a bunch of built-in terminal emulators.
And they all suck.
(OK not really, eshell is alright, but not for interactive terminal programs like newsboat/neomutt)

Also use emacsclient inside vterm as an editor, because that'll open documents in the existing Emacs session.
And I'm not gonna be a heretic and open Vim inside of Emacs.

#+begin_src emacs-lisp
  (use-package vterm
    :config
    (setq vterm-environment '("EDITOR=emacsclient"))
    :hook
    (vterm-mode . (lambda () (unless server-process (server-start)))))
#+end_src

* Interface
** GUI elements
   Get rid of all bars.

   #+begin_src emacs-lisp
     (setq org-src-tab-acts-natively t)
     (when window-system
       (menu-bar-mode -1)
       (tool-bar-mode -1)
       (scroll-bar-mode -1)
       (tooltip-mode -1))
   #+end_src

** Messages
   Hide some messages I don't need.

   #+begin_src emacs-lisp
     (setq inhibit-startup-message t)
     (setq initial-scratch-message "")
   #+end_src

** Appearance
*** Cursor line
    Highlight the current line:

    #+begin_src emacs-lisp
      (global-hl-line-mode)
      (show-paren-mode 1)
    #+end_src
*** Line numbers
    Relative line numbers:

    #+begin_src emacs-lisp
      (setq display-line-numbers-type 'relative)
      (global-display-line-numbers-mode)
    #+end_src

    Don't display them in specific modes.  For each of the modes in
    'mode-hooks', add a function to hide line numbers when the mode
    activates (which triggers the 'mode'-hook).

    #+begin_src emacs-lisp
      (let ((mode-hooks '(doc-view-mode-hook vterm-mode-hook mpc-status-mode-hook mpc-tagbrowser-mode-hook)))
        (mapc
         (lambda (mode-name)
           (add-hook mode-name (lambda () (display-line-numbers-mode 0))))
         mode-hooks))
    #+end_src
*** Modeline
I want to show the time and date in the modeline:

#+begin_src emacs-lisp
  (setq display-time-day-and-date t           ; also the date
        display-time-default-load-average nil ; don't show load average
        display-time-format "%I:%M%p%e %b"    ; "HR:MIN(AM/PM) day-of-month Month"
        display-time-mode 1)                  ; enable time mode
#+end_src

I want to show the current function:

#+begin_src emacs-lisp
  (which-function-mode 1)
#+end_src

Maybe at some point I'll customize the modeline too.
** Buffer displaying

So, this is a bit hard to grok. But basically the alist contains a
regular expression to match a buffer name, then a list of functions to
use in order for displaying the list, and then options for those functions (each of which is an alist).

#+begin_src emacs-lisp
  (setq
   ;; Maximum number of side-windows to create on (left top right bottom)
   window-sides-slots '(0   ;; left
                        1   ;; top
                        3   ;; right
                        1 ) ;; bottom

   display-buffer-alist '(
     ;; Right side
     ("\\*Help\\*"
      (display-buffer-reuse-window display-buffer-in-side-window)
      (side . right)
      (slot . -1)
      (inhibit-same-window . t))
     ("\\*Async Shell Command\\*"
      (display-buffer-reuse-window display-buffer-in-side-window)
      (side . right)
      (slot . 0)
      (inhibit-same-window . t))
     ("magit-process: .*"
      (display-buffer-reuse-window display-buffer-in-side-window)
      (side . right)
      (slot . 0)
      (inhibit-same-window . t))

     ;; Top side
     ("\\*Info\\*"
      (display-buffer-reuse-window display-buffer-in-side-window)
      (side . top)
      (slot . 0))
     ("\\*Man .*\\*"
      (display-buffer-reuse-window display-buffer-in-side-window)
      (side . top)
      (slot . 0))))
#+end_src

And a way to toggle those side windows:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w") (lambda () (interactive) (window-toggle-side-windows)))
#+end_src

* File locations
** Auto-Save files
  By default, auto-save files ("#file#") are placed in the same directory as the file itself.
  I want to put this all in some unified place:

  #+begin_src emacs-lisp
    (setq auto-save-file-name-transforms
	  `((".*" "~/.local/share/emacs/saves/" t)))
  #+end_src

** Backup files
  By default, backup files (those with a tilde) are saved in the same directory as the currently edited file.
  This setting puts them in ~/.local/share/emacs/backups.

  #+begin_src emacs-lisp
    (setq backup-directory-alist '(("." . "~/.local/share/emacs/backups")))
    (setq backup-by-copying t)
  #+end_src

** Custom settings file
Both commands are necessary.
First one tells Emacs where to save customizations.
The second one actually loads them.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "~/.emacs.d/custom.el"))
  (load custom-file)
#+end_src

* Editor
** Strip trailing whitespace
   You can show trailing whitespace by setting show-trailing-whitespace to 't'.
   But I want to automatically strip trailing whitespace.
   Luckily there's already a function for that, I just need to call it in a hook:

   #+begin_src emacs-lisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+end_src
** Auto-formatting
Disable fill mode in Markdown

#+begin_src emacs-lisp
  (add-hook 'markdown-mode-hook (lambda () (auto-fill-mode 0) (flyspell-mode 1)))
#+end_src

Never insert tabs with indentation:

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

** Wrapping
   I want to wrap text at window boundary for some modes:

   #+begin_src emacs-lisp
     (add-hook 'org-mode-hook (lambda ()
				(visual-line-mode)
				(org-indent-mode)))
     (add-hook 'markdown-mode-hook (lambda () (visual-line-mode)))
   #+end_src

** Pulse line
   Set some options for pulsing:

   #+begin_src emacs-lisp
     (setq pulse-iterations 10)
     (setq pulse-delay 0.05)
   #+end_src

   Define the pulse function:

   #+begin_src emacs-lisp
     (defun pulse-line (&rest _)
       "Pulse the current line."
       (pulse-momentary-highlight-one-line (point)))
   #+end_src

   Run it in certain cases: scrolling up/down, recentering, switching windows.
   'dolist' binds 'command' to each value in the list in turn, and runs the body.
   'advice-add' makes the pulse-line function run after 'command'.

   #+begin_src emacs-lisp
     (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
       (advice-add command :after #'pulse-line))
   #+end_src
** Pager mode
   M-x view-mode enables pager behavior.
   I want read-only files to automatically use pager mode:

   #+begin_src emacs-lisp
     (setq view-read-only t)
   #+end_src
** Mail mode for neomutt
   When editing a message from neomutt, I want to use mail mode.
   Even though I won't be sending the email from there, I like the syntax highlighting :)

   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("/neomutt-" . mail-mode))
   #+end_src
** Zap up to char
It's more useful for me to be able to delete up to a character instead of to and including a character:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+end_src
** Expand
Use hippie expand instead of dabbrev-expand:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

** Prefer newer file loading
#+begin_src emacs-lisp
(setq load-prefer-newer t)
#+end_src

** Automatically find tags file
When opening a file in a git repo, try to discover the etags file:

#+begin_src emacs-lisp
  (add-hook 'find-file-hook
            (lambda () (let* ((tagspath ".git/etags")
                              (git-root (locate-dominating-file (buffer-file-name) tagspath)))
                         (if git-root
                             (visit-tags-table (expand-file-name tagspath git-root) 1)))))
#+end_src

There's probably a better way to write this. I need to ask Reddit for feedback at some point.

** Semantic mode
Set default submodes:

#+begin_src emacs-lisp
  (setq semantic-default-submodes '(global-semantic-idle-scheduler-mode ; reparse buffer when idle
                                   global-semanticdb-minor-mode ; maintain database
                                   global-semantic-idle-summary-mode ; show information (e.g. types) about tag at point
                                   global-semantic-stickyfunc-mode)) ; show current funt in header line
#+end_src

SemanticDB is written into ~/.emacs.d/semanticdb/.

Enable semantic mode for major modes:

#+begin_src emacs-lisp
  (let ((mode-hooks '(c-mode-common-hook)))
         (mapc (lambda (mode-name)
                 (add-hook mode-name (lambda () (semantic-mode 1))))
          mode-hooks))
#+end_src

** Forward-word and forward-to-word
Change M-f to stop at the start of the word:

#+begin_src emacs-lisp
(global-set-key (kbd "M-f") 'forward-to-word)
#+end_src

Bind M-F to the old functionality of M-f (stop at end of word)

#+begin_src emacs-lisp
(global-set-key (kbd "M-F") 'forward-word)
#+end_src

** Rectangle insert string
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x r I") 'string-insert-rectangle)
#+end_src

** Org mode - yank URL
#+begin_src emacs-lisp
  (defun org-yank-link-url ()
    (interactive)
    (kill-new (org-element-property :raw-link (org-element-context))))

  (define-key org-mode-map (kbd "C-c M-y") 'org-yank-link-url)
#+end_src

* Misc settings
** Enable all commands
   By default, Emacs disables some commands.
   I want to have these enabled so I don't get a prompt whenever I try to use a disabled command.

   #+begin_src emacs-lisp
     (setq disabled-command-function nil)
   #+end_src
** More extensive apropos
#+begin_src emacs-lisp
(setq apropos-do-all t)
#+end_src
** Easily edit my config
Bind a keyboard shortcut to open my config.
The "(interactive)" means that it can be called from a keybinding or from M-x (though since it's a lambda, it can't be called from M-x).

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c E") (lambda () (interactive) (find-file (expand-file-name "config.org" user-emacs-directory))))
#+end_src
** Org notification
macOS doesn't have dbus. So I use terminal-notifier for functions like org-notify:

#+begin_src emacs-lisp
  (if (and (eq system-type 'darwin)
           (executable-find "terminal-notifier"))
      (setq org-show-notification-handler
            (lambda (str) (start-process "terminal-notifier" nil (executable-find "terminal-notifier")
                                         "-title" "Timer done"
                                         "-message" str
                                         "-group" "org.gnu.Emacs"
                                         "-sender" "org.gnu.Emacs"))))
#+end_src

* Notmuch
Define some saved searches (i.e. mailboxes):

#+begin_src emacs-lisp
  (setq notmuch-saved-searches
      `((:name "inbox: personal" :query "folder:/alex@balgavy.eu/ tag:inbox" :key ,(kbd "ip"))
        (:name "inbox: school" :query "folder:/a.balgavy@student.vu.nl/ tag:inbox" :key ,(kbd "is"))
        (:name "archive: personal" :query "folder:/alex@balgavy.eu/ tag:archive" :key ,(kbd "ap"))
        (:name "archive: school" :query "folder:/a.balgavy@student.vu.nl/ tag:archive" :key ,(kbd "as"))))
#+end_src

Define the main screen sections:

#+begin_src emacs-lisp
  (setq notmuch-hello-sections
      '(notmuch-hello-insert-header
        notmuch-hello-insert-saved-searches
        notmuch-hello-insert-search
        notmuch-hello-insert-alltags
        notmuch-hello-insert-footer))
#+end_src

Global keybindings:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c m") #'notmuch)
#+end_src

Show newest mail first:

#+begin_src emacs-lisp
  (setq notmuch-search-oldest-first nil)
#+end_src

Set tags:

#+begin_src emacs-lisp
  (setq notmuch-archive-tags '("-inbox" "+archive"))
  (setq notmuch-show-mark-unread-tags '("+unread"))
  (setq notmuch-delete-tags '("-inbox" "+trash"))

  (setq notmuch-tagging-keys '(("a" notmuch-archive-tags "Archive")
                               ("r" notmuch-show-mark-read-tags "Mark read")
                               ("u" notmuch-show-mark-unread-tags "Mark unread")
                               ("d" notmuch-delete-tags "Delete")))
#+end_src

* MPC
Set the windows I want to show:

#+begin_src emacs-lisp
  (setq mpc-browser-tags '(Artist Album Genre))
#+end_src

Define some keybindings:

#+begin_src emacs-lisp
  (add-hook 'mpc-mode-hook
            (lambda ()
              (define-key mpc-mode-map "a" #'mpc-playlist-add)
              (define-key mpc-mode-map "P" #'mpc-playlist)
              (define-key mpc-mode-map "x" #'mpc-playlist-delete)
              (define-key mpc-mode-map "f" (lambda () "Seek forward 20 seconds" (interactive) (mpc-seek-current "+20")))
              (define-key mpc-mode-map "b" (lambda () "Seek backward 20 seconds" (interactive) (mpc-seek-current "-20")))))
#+end_src

Unfortunately the lambda keybindings don't show up documented properly, but oh well. That's a minor problem.

* References
  Here's a list of good articles I encountered about configging emacs:
  - [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]]
  - [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with emacs]]
