* Theme
Icons required for some parts of the doom theme:

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

Load Doom Emacs themes:

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)

    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

Define the themes I want:

#+begin_src emacs-lisp
  (setq dark-theme-name 'doom-one)
  (setq light-theme-name 'jokull)
  ;; I used to use doom-acario-light before writing my own theme

  (defun dark-theme ()
    "Switch to dark theme"
    (interactive)
    (load-theme dark-theme-name t)
    (add-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode))

  (defun light-theme ()
    "Switch to light theme"
    (interactive)
    (load-theme light-theme-name t)
    (remove-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode))
#+end_src

Change theme depending on the current system theme.
The way I check for dark mode is defined in 'dark-mode-p'; currently I use the presence of the ~/.config/dark-theme file to indicate when dark theme is set.
A function ending in '-p' is a predicate, i.e. returns true or false.
If calling a function that's in a variable, you have to use 'funcall'.
To evaluate a quoted form, use 'eval'.

#+begin_src emacs-lisp
  (let ((dark-mode-p '(file-exists-p "~/.config/dark-theme")))
    (if (eval dark-mode-p)
        (dark-theme)
      (light-theme)))
#+end_src

* Garbage collection
Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+begin_src emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+end_src

* Package management
** Repositories (MELPA & Org)

Set up packages:

#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))
#+end_src

Refresh packages async:

#+begin_src emacs-lisp
  (package-initialize)
  (package-refresh-contents t)
#+end_src

* Packages
** exec-path-from-shell (macOS)
In macOS, the path is not set correctly in the GUI app. This fixes it.

#+begin_src emacs-lisp
  (when (string-equal system-type "darwin")
    (use-package exec-path-from-shell
      :config
      (add-to-list 'exec-path-from-shell-variables "NOTMUCH_CONFIG")
      (exec-path-from-shell-initialize)))
#+end_src

** emacs-which-key
Minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src

** counsel + ivy + swiper
Better incremental completion and selection narrowing.
And a bunch more.
Generally makes for nicer interactivity, like ido mode on steroids.
Switched to this from Helm, it's more lightweight.

#+begin_src emacs-lisp
  (use-package counsel :demand
    :bind
    (("C-s" . swiper-isearch)
     ("C-r" . swiper-isearch-backward)
     ("M-x" . counsel-M-x)
     ("C-x C-f" . counsel-find-file)
     ("M-y" . counsel-yank-pop)
     ("<f1> f" . counsel-describe-function)
     ("<f1> v" . counsel-describe-variable)
     ("<f1> l" . counsel-find-library)
     ("<f2> i" . counsel-info-lookup-symbol)
     ("<f2> u" . counsel-unicode-char)
     ("<f2> j" . counsel-set-variable)
     ("C-x b" . ivy-switch-buffer)
     ("C-c v" . ivy-push-view)
     ("C-c V" . ivy-pop-view)
     ("C-c c" . counsel-compile)
     ("C-c g" . counsel-git)
     ("C-c j" . counsel-git-grep)
     ("C-c L" . counsel-git-log)
     ("C-c k" . counsel-ag)
     ("C-c m" . counsel-linux-app)
     ("C-c n" . counsel-fzf)
     ("C-x l" . counsel-locate)
     ("C-c J" . counsel-file-jump)
     ("C-S-o" . counsel-rhythmbox)
     ("C-c C-r" . ivy-resume)
     ("C-c b" . counsel-bookmark)
     ("C-c d" . counsel-descbinds)
     ("C-c g" . counsel-git)
     ("C-c o" . counsel-outline)
     ("C-c t" . counsel-load-theme)
     ("C-c F" . counsel-org-file)
     ("C-x C-i" . counsel-imenu))
    :config
    (setq ivy-use-virtual-buffers t       ; extend searching to bookmarks and
          ivy-height 20                   ; set height of the ivy window
          ivy-count-format "(%d/%d) "     ; count format, from the ivy help page
          ivy-display-style 'fancy
          ivy-format-function 'ivy-format-function-line)
    (ivy-mode)
    (counsel-mode)

    (defun edit-script ()
      "Edit a file in ~/.scripts/"
      (interactive)
      (let ((input (ivy--input)))
        (ivy-quit-and-run (counsel-file-jump nil "~/.scripts/"))))
    (defun edit-config ()
      "Edit a file in ~/.dotfiles/"
      (interactive)
      (let ((input (ivy--input)))
        (ivy-quit-and-run (counsel-file-jump nil "~/.dotfiles/")))))
#+end_src

** org
In org mode, I want to use bullets instead of stars.
Also, I add a few expansions

#+begin_src emacs-lisp
  (use-package org
    :config
    (unless (package-installed-p 'org-bullets)
      (package-refresh-contents)
      (package-install 'org-bullets))
    (require 'org-bullets)
    (require 'org-tempo)

    :hook
    (org-mode . (lambda () (org-bullets-mode 1))))
#+end_src

** lean-mode
Specifically for the Lean prover.
I also install company-lean and helm-lean, which are suggested on the [[https://github.com/leanprover/lean-mode][Github page]].
Then I map company-complete only for lean-mode.

#+begin_src emacs-lisp
  (use-package lean-mode
    :config
    (use-package company-lean)
    :hook
    (lean-mode . (lambda () (define-key lean-mode-map (kbd "S-SPC") #'company-complete))))
#+end_src

** magit
#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** vterm
Emacs has a bunch of built-in terminal emulators.
And they all suck.
(OK not really, eshell is alright, but not for interactive terminal programs like newsboat/neomutt)

Also use emacsclient inside vterm as an editor, because that'll open documents in the existing Emacs session.
And I'm not gonna be a heretic and open Vim inside of Emacs.

#+begin_src emacs-lisp
  (use-package vterm
    :config
    (setq vterm-environment '("EDITOR=emacsclient"))
    :hook
    (vterm-mode . (lambda () (unless server-process (server-start)))))
#+end_src

I'll bind a key to start a vterm or switch to the running vterm:

#+begin_src emacs-lisp
  (defun switch-to-vterm () "Switch to a running vterm, or start one and switch to it."
         (interactive)
         (if (get-buffer vterm-buffer-name)
             (switch-to-buffer vterm-buffer-name)
           (vterm)))
  (global-set-key (kbd "C-c t") 'switch-to-vterm)
#+end_src

** sr-speedbar
Make speed bar show in the current frame.

#+begin_src emacs-lisp
  (use-package sr-speedbar
    :config
    (setq sr-speedbar-right-side nil)
    (define-key speedbar-mode-map (kbd "q") 'sr-speedbar-close)
    :bind
    (("C-c F" . sr-speedbar-toggle)))

#+end_src

Jump to speedbar. sr-speedbar-exist-p can be void, so I check if it's bound first.
If it's not bound, or if it's false, first open the speedbar.
Then, select it.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c f") (lambda () (interactive)
                                  (if (or (not (boundp 'sr-speedbar-exist-p))
                                          (not (sr-speedbar-exist-p)))
                                      (sr-speedbar-open))
                                  (sr-speedbar-select-window)))
#+end_src

** expand-region
Expand the selected region semantically.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

** flycheck
Install flycheck, and enable it in certain major modes:

#+begin_src emacs-lisp
  (use-package flycheck
    :hook (sh-mode . flycheck-mode))
#+end_src

** anki-editor
Some extra keybindings that are not set up by default.
anki-editor doesn't provide a keymap so I have to set one up here:

#+begin_src emacs-lisp
  (use-package anki-editor
    :config
    (defvar anki-editor-mode-map (make-sparse-keymap))
    (add-to-list 'minor-mode-map-alist (cons 'anki-editor-mode
                                             anki-editor-mode-map))

    (setq anki-editor-use-math-jax t)

    :hook
    (anki-editor-mode . (lambda ()
                          (define-key anki-editor-mode-map (kbd "C-c t") #'org-property-next-allowed-value)
                          (define-key anki-editor-mode-map (kbd "C-c i") #'anki-editor-insert-note)
                          (define-key anki-editor-mode-map (kbd "C-c p") #'anki-editor-push-notes)
                          (define-key anki-editor-mode-map (kbd "C-c c") #'anki-editor-cloze-dwim))))
#+end_src

** rainbow-mode
'rainbow-mode' lets you visualise hex colors:

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :hook (emacs-lisp-mode . rainbow-mode))
#+end_src

** pdf-tools
A better replacement for DocView:

#+begin_src emacs-lisp
  (use-package pdf-tools
    :hook
    (pdf-annot-list-mode . pdf-annot-list-follow-minor-mode)
    (pdf-annot-edit-contents-minor-mode . org-mode)
    (pdf-view-mode . (lambda () (display-line-numbers-mode 0)))
    (pdf-view-mode . (lambda () (define-key pdf-isearch-minor-mode-map (kbd "C-s") #'isearch-forward))))
  (pdf-tools-install)
#+end_src

** virtualenvwrapper
Like virtualenvwrapper.sh, but for Emacs.

#+begin_src emacs-lisp
  (use-package virtualenvwrapper
    :config
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    (setq venv-location "~/.config/virtualenvs"))
#+end_src

** org-ref
#+begin_src emacs-lisp
  (use-package org-ref)
#+end_src

** org-noter
#+begin_src emacs-lisp
  (use-package org-noter)
#+end_src

** hl-todo
I want to highlight TODO keywords in comments:

#+begin_src emacs-lisp
  (use-package hl-todo
    :custom-face
    (hl-todo ((t (:inherit hl-todo :underline t))))
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#ff7060")
            ("FIXME"  . "#caa000"))))
#+end_src

(global-hl-todo-mode t)
* Interface
** Messages
Hide some messages I don't need.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")
#+end_src

** Appearance
*** Cursor line
Highlight the current line:

#+begin_src emacs-lisp
  (global-hl-line-mode)
  (show-paren-mode 1)
#+end_src

*** Cursor
The default box cursor isn't really accurate, because the cursor is actually between letters, not on a letter.
So, I want a bar instead of a box:

#+begin_src emacs-lisp
  (setq-default cursor-type '(bar . 4)
                cursor-in-non-selected-windows 'hollow)
#+end_src

(I use ~setq-default~ here because cursor-type is automatically buffer-local when it's set)

*** Line numbers
Relative line numbers:

#+begin_src emacs-lisp
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)
#+end_src

Don't display them in specific modes.  For each of the modes in
'mode-hooks', add a function to hide line numbers when the mode
activates (which triggers the 'mode'-hook).

#+begin_src emacs-lisp
  (let ((mode-hooks '(doc-view-mode-hook vterm-mode-hook mpc-status-mode-hook mpc-tagbrowser-mode-hook)))
    (mapc
     (lambda (mode-name)
       (add-hook mode-name (lambda () (display-line-numbers-mode 0))))
     mode-hooks))
#+end_src
*** Modeline
I want to show the time and date in the modeline:

#+begin_src emacs-lisp
  (setq display-time-day-and-date t           ; also the date
        display-time-default-load-average nil ; don't show load average
        display-time-format "%I:%M%p %e %b (%a)")   ; "HR:MIN(AM/PM) day-of-month Month (Day)"
  (display-time-mode 1)                  ; enable time mode
#+end_src

I want to show the current function:

#+begin_src emacs-lisp
  (which-function-mode 1)
#+end_src

And to set the modeline format:

#+begin_src emacs-lisp
  (setq-default mode-line-format '("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position
                                   (vc-mode vc-mode)
                                   "  " mode-line-modes mode-line-misc-info mode-line-end-spaces))
#+end_src

I want to hide certain modes from the modeline, they're always on:

#+begin_src emacs-lisp
  (use-package diminish
    :config
    (let ((modes-to-hide '(ivy-mode counsel-mode which-key-mode)))
      (mapc (lambda (mode-name) (diminish mode-name)) modes-to-hide)))
#+end_src

** Buffer displaying

So, this is a bit hard to grok. But basically the alist contains a
regular expression to match a buffer name, then a list of functions to
use in order for displaying the list, and then options for those functions (each of which is an alist).

#+begin_src emacs-lisp
  (setq
   ;; Maximum number of side-windows to create on (left top right bottom)
   window-sides-slots '(0   ;; left
                        1   ;; top
                        3   ;; right
                        1 ) ;; bottom

   display-buffer-alist '(
                          ;; Right side
                          ("\\*Help\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . -1)
                           (inhibit-same-window . t))
                          ("\\*Async Shell Command\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . 0)
                           (inhibit-same-window . t))
                          ("magit-process: .*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . 0)
                           (inhibit-same-window . t))

                          ;; Top side
                          ("\\*Info\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . top)
                           (slot . 0))
                          ("\\*Man .*\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . top)
                           (slot . 0))

                          ;; Bottom
                          ("\\*Flycheck errors\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . bottom)
                           (slot . 0))))
#+end_src

And a way to toggle those side windows:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w") (lambda () (interactive) (window-toggle-side-windows)))
#+end_src

* File locations
** Auto-Save files
By default, auto-save files ("#file#") are placed in the same directory as the file itself.
I want to put this all in some unified place:

#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms
        `((".*" "~/.local/share/emacs/saves/" t)))
#+end_src

** Backup files
By default, backup files (those with a tilde) are saved in the same directory as the currently edited file.
This setting puts them in ~/.local/share/emacs/backups.

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.local/share/emacs/backups")))
  (setq backup-by-copying t)
#+end_src

** Custom settings file
Both commands are necessary.
First one tells Emacs where to save customizations.
The second one actually loads them.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
  (load custom-file)
#+end_src

* Editor
** Overwrite selection on typing
Normally, when I select something and start typing, Emacs clears the selection.
I want to replace the selection.

#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src

** Strip trailing whitespace
You can show trailing whitespace by setting show-trailing-whitespace to 't'.
But I want to automatically strip trailing whitespace.
Luckily there's already a function for that, I just need to call it in a hook:

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** Auto-formatting
Disable fill mode in Markdown

#+begin_src emacs-lisp
  (add-hook 'markdown-mode-hook (lambda () (auto-fill-mode 0) (flyspell-mode 1)))
#+end_src

A tab is 8 spaces:

#+begin_src emacs-lisp
  (setq-default tab-width 8)
#+end_src

Never insert tabs with indentation:

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Allow switching between the two easily:

#+begin_src emacs-lisp
  (defun indent-tabs ()
    (interactive)
    (setq indent-tabs-mode t))
  (defun indent-spaces ()
    (interactive)
    (setq indent-tabs-mode nil))
#+end_src

Indentation for various modes:

#+begin_src emacs-lisp
  (setq-default sh-basic-offset 2
                c-basic-offset 4)
#+end_src

** Wrapping
I want to wrap text at window boundary for some modes:

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook (lambda ()
                             (visual-line-mode)
                             (org-indent-mode)))
  (add-hook 'markdown-mode-hook (lambda () (visual-line-mode)))
#+end_src

** Pulse line
Set some options for pulsing:

#+begin_src emacs-lisp
  (setq pulse-iterations 10)
  (setq pulse-delay 0.05)
#+end_src

Define the pulse function:

#+begin_src emacs-lisp
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))
#+end_src

Run it in certain cases: scrolling up/down, recentering, switching windows.
'dolist' binds 'command' to each value in the list in turn, and runs the body.
'advice-add' makes the pulse-line function run after 'command'.

#+begin_src emacs-lisp
  (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
    (advice-add command :after #'pulse-line))
#+end_src
** Pager mode
M-x view-mode enables pager behavior.
I want read-only files to automatically use pager mode:

#+begin_src emacs-lisp
  (setq view-read-only t)
#+end_src
** Mail mode for neomutt
When editing a message from neomutt, I want to use mail mode.
Even though I won't be sending the email from there, I like the syntax highlighting :)

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("/neomutt-" . mail-mode))
#+end_src
** Zap up to char
It's more useful for me to be able to delete up to a character instead of to and including a character:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+end_src
** Expand
Use hippie expand instead of dabbrev-expand:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

** Prefer newer file loading
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

** Automatically find tags file
When opening a file in a git repo, try to discover the etags file:

#+begin_src emacs-lisp
  (defun current-tags-file ()
    "Get current tags file"
    (let* ((tagspath ".git/etags")
           (git-root (locate-dominating-file (buffer-file-name) tagspath)))
      (if git-root
          (expand-file-name tagspath git-root))))

  (setq default-tags-table-function #'current-tags-file)
#+end_src

There's probably a better way to write this. I need to ask Reddit for feedback at some point.

** Semantic mode
Set default submodes:

#+begin_src emacs-lisp
  (setq semantic-default-submodes '(global-semantic-idle-scheduler-mode ; reparse buffer when idle
                                    global-semanticdb-minor-mode ; maintain database
                                    global-semantic-idle-summary-mode)) ; show information (e.g. types) about tag at point
  ;; global-semantic-stickyfunc-mode)) ; show current func in header line
#+end_src

Add some keybindings:

#+begin_src emacs-lisp
  (with-eval-after-load 'semantic
    (define-key semantic-mode-map (kbd "C-c , .") #'semantic-ia-show-summary))
#+end_src

SemanticDB is written into ~/.emacs.d/semanticdb/.

Enable semantic mode for major modes:

#+begin_src emacs-lisp
  (let ((mode-hooks [c-mode-common-hook]))
    (mapc (lambda (mode-name)
            (add-hook mode-name (lambda () (semantic-mode 1))))
          mode-hooks))
#+end_src

** Forward-word and forward-to-word
Change M-f to stop at the start of the word:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-f") 'forward-to-word)
#+end_src

Bind C-M-S-F to the old functionality of M-f (stop at end of word)

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-S-F") 'forward-word)
#+end_src

** Rectangle insert string
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x r I") 'string-insert-rectangle)
  (global-set-key (kbd "C-x r R") 'replace-rectangle)
#+end_src

* Org mode
** Yank URL
#+begin_src emacs-lisp
  (defun org-yank-link-url ()
    (interactive)
    (kill-new (org-element-property :raw-link (org-element-context))))

  (define-key org-mode-map (kbd "C-c M-y") 'org-yank-link-url)
#+end_src

** Catch invisible edits
Sometimes when text is folded away, I might accidentally edit text inside of it.
This option prevents that.
I wanted to do 'smart', but that has a 'fixme' so it might change in the future...
Instead, show what's being edited, but don't perform the edit.

#+begin_src emacs-lisp
  (setq org-catch-invisible-edits 'show-and-error)
#+end_src

** Notification
macOS doesn't have dbus. So I use terminal-notifier for functions like org-notify:

#+begin_src emacs-lisp
  (if (and (eq system-type 'darwin)
           (executable-find "terminal-notifier"))
      (setq org-show-notification-handler
            (lambda (str) (start-process "terminal-notifier" nil (executable-find "terminal-notifier")
                                         "-title" "Timer done"
                                         "-message" str
                                         "-group" "org.gnu.Emacs"
                                         "-sender" "org.gnu.Emacs"))))
#+end_src
* Python
In Python, I want to enable flycheck and semantic mode:

#+begin_src emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
  (add-hook 'python-mode-hook 'semantic-mode)
#+end_src

* Misc settings
** Enable all commands
By default, Emacs disables some commands.
I want to have these enabled so I don't get a prompt whenever I try to use a disabled command.

#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

** More extensive apropos
#+begin_src emacs-lisp
  (setq apropos-do-all t)
#+end_src
** Easily edit my config
Bind a keyboard shortcut to open my config.
The "(interactive)" means that it can be called from a keybinding or from M-x (though since it's a lambda, it can't be called from M-x).

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c E") (lambda () (interactive) (find-file (expand-file-name "config.org" user-emacs-directory))))
#+end_src
** Fast access to view-mode (pager)
I want to bind view-mode to a key for easy access:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c v") 'view-mode)
#+end_src

** Kill this buffer
I like to be able to kill a buffer instantly:

#+begin_src emacs-lisp
  (global-set-key (kbd "s-<backspace>") 'kill-current-buffer)
#+end_src

** Toggle fullscreen
I'll use the keybinding that's standard on macOS:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s-f") #'toggle-frame-fullscreen)
#+end_src

* Notmuch
Define some saved searches (i.e. mailboxes):

#+begin_src emacs-lisp
  (setq notmuch-saved-searches
        `((:name "inbox: personal" :query "folder:/alex@balgavy.eu/ tag:inbox" :key ,(kbd "ip"))
          (:name "inbox: school" :query "folder:/a.balgavy@student.vu.nl/ tag:inbox" :key ,(kbd "is"))
          (:name "archive: personal" :query "folder:/alex@balgavy.eu/ tag:archive" :key ,(kbd "ap"))
          (:name "archive: school" :query "folder:/a.balgavy@student.vu.nl/ tag:archive" :key ,(kbd "as"))))
#+end_src

Define the main screen sections:

#+begin_src emacs-lisp
  (setq notmuch-hello-sections
        '(notmuch-hello-insert-header
          notmuch-hello-insert-saved-searches
          notmuch-hello-insert-search
          notmuch-hello-insert-alltags
          notmuch-hello-insert-footer))
#+end_src

Global keybindings:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c m") #'notmuch)
#+end_src

Show newest mail first:

#+begin_src emacs-lisp
  (setq notmuch-search-oldest-first nil)
#+end_src

Set tags:

#+begin_src emacs-lisp
  (setq notmuch-archive-tags '("-inbox" "+archive"))
  (setq notmuch-show-mark-unread-tags '("+unread"))
  (setq notmuch-delete-tags '("-inbox" "+trash"))

  (setq notmuch-tagging-keys '(("a" notmuch-archive-tags "Archive")
                               ("r" notmuch-show-mark-read-tags "Mark read")
                               ("u" notmuch-show-mark-unread-tags "Mark unread")
                               ("d" notmuch-delete-tags "Delete")))
#+end_src

Run notmuch-hook script on hello refresh, to move messages to folders according to their tags:

#+begin_src emacs-lisp
  (add-hook 'notmuch-hello-refresh-hook (lambda () (start-process "notmuch-hook" nil "notmuch-hook" "tags2folders")))
#+end_src
* MPC
Set the windows I want to show:

#+begin_src emacs-lisp
  (setq mpc-browser-tags '(AlbumArtist Album Genre Playlist))
#+end_src

Define some keybindings:

#+begin_src emacs-lisp
  (add-hook 'mpc-mode-hook
            (lambda ()
              (define-key mpc-mode-map "a" #'mpc-playlist-add)
              (define-key mpc-mode-map "P" #'mpc-playlist)
              (define-key mpc-mode-map "x" #'mpc-playlist-delete)
              (define-key mpc-mode-map "p" #'mpc-toggle-play)
              (define-key mpc-mode-map "t" #'mpc-select-toggle)
              (define-key mpc-mode-map "f" (lambda () "Seek forward 20 seconds" (interactive) (mpc-seek-current "+20")))
              (define-key mpc-mode-map "b" (lambda () "Seek backward 20 seconds" (interactive) (mpc-seek-current "-20")))))
#+end_src

Unfortunately the lambda keybindings don't show up documented properly, but oh well. That's a minor problem.

* Radio
Just a wrapper function to my radio script:

#+begin_src emacs-lisp
  (defun radio ()
    "Play an internet radio"
    (interactive)
    (ansi-term "radio" "*radio*"))
#+end_src

* Dired
'i' expands subdirs, so I want to be able to close them too.

#+begin_src emacs-lisp
  (define-key dired-mode-map (kbd "M-k") #'dired-kill-subdir)
#+end_src

Set up listing display:

#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-alhv")
#+end_src

By default, hide details (show again by pressing oparen):

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src

If I have another dired window open, use that as target:

#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src

* References
Here's a list of good articles I encountered about configging emacs:
- [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]]
- [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with emacs]]
