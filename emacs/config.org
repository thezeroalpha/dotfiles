* Theme
Icons required for some parts of the doom theme:

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

Load Doom Emacs themes:

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)

    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

Define the themes I want:

#+begin_src emacs-lisp
  (setq dark-theme-name 'doom-one)
  (setq light-theme-name 'jokull)
  ;; I used to use doom-acario-light before writing my own theme

  (defun dark-theme ()
    "Switch to dark theme"
    (interactive)
    (load-theme dark-theme-name t)
    (add-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode))

  (defun light-theme ()
    "Switch to light theme"
    (interactive)
    (load-theme light-theme-name t)
    (remove-hook 'pdf-view-mode-hook #'pdf-view-midnight-minor-mode))
#+end_src

Change theme depending on the current system theme.
The way I check for dark mode is defined in 'dark-mode-p'; currently I use the presence of the ~/.config/dark-theme file to indicate when dark theme is set.
I quote the call to ~file-exists-p~ because I want to evaluate it on-demand, not immediately.
A function ending in '-p' is a predicate, i.e. returns true or false.
If calling a function that's in a variable, you have to use 'funcall'.
To evaluate a quoted form, use 'eval'.

#+begin_src emacs-lisp
  (let ((dark-mode-p '(file-exists-p "~/.config/dark-theme")))
    (if (eval dark-mode-p)
        (dark-theme)
      (light-theme)))
#+end_src

* Font
I want Menlo, size 14:

#+begin_src emacs-lisp
  (set-frame-font "Menlo-14" nil t)
#+end_src

* Garbage collection
Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+begin_src emacs-lisp
  (add-hook 'focus-out-hook #'garbage-collect)
#+end_src

* Packages
** quelpa
Quelpa lets you install from local or remote source (like git).
With quelpa-use-package, I can use the keyword ~:quelpa~ to install via quelpa.

#+begin_src emacs-lisp
  (use-package quelpa)
  (use-package quelpa-use-package)
#+end_src

** exec-path-from-shell (macOS)
In macOS, the path is not set correctly (i.e. as it is in the terminal) in the GUI app. This fixes it.

#+begin_src emacs-lisp
  (when (string-equal system-type "darwin")
    (use-package exec-path-from-shell
      :config
      (add-to-list 'exec-path-from-shell-variables "NOTMUCH_CONFIG")
      (exec-path-from-shell-initialize)))
#+end_src

** emacs-which-key
Minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src

** counsel + ivy + swiper
Better incremental completion and selection narrowing.
And a bunch more.
Generally makes for nicer interactivity, like ido mode on steroids.
Switched to this from Helm, it's more lightweight.

#+begin_src emacs-lisp
  (use-package counsel :demand
    :bind
    (("C-s" . swiper-isearch)
     ("C-r" . swiper-isearch-backward)
     ("M-x" . counsel-M-x)
     ("C-x C-f" . counsel-find-file)
     ("M-y" . counsel-yank-pop)
     ("C-x b" . ivy-switch-buffer)
     ("C-c v" . ivy-push-view)
     ("C-c V" . ivy-pop-view)
     ("C-c c" . counsel-compile)
     ("C-c k" . counsel-ag)
     ("C-c f" . counsel-fzf)
     ("C-c b" . counsel-bookmark)
     ("C-c d" . counsel-descbinds)
     ("C-c o" . counsel-outline))

    :config
    (setq ivy-use-virtual-buffers t       ; extend searching to bookmarks and
          ivy-height 20                   ; set height of the ivy window
          ivy-count-format "(%d/%d) "     ; count format, from the ivy help page
          ivy-display-style 'fancy
          ivy-format-function 'ivy-format-function-line)
    (ivy-mode)
    (counsel-mode)

    (defun edit-script ()
      "Edit a file in ~/.scripts/"
      (interactive)
      (let ((input (ivy--input)))
        (ivy-quit-and-run (counsel-file-jump nil "~/.scripts/"))))
    (defun edit-config ()
      "Edit a file in ~/.dotfiles/"
      (interactive)
      (let ((input (ivy--input)))
        (ivy-quit-and-run (counsel-file-jump nil "~/.dotfiles/")))))
#+end_src

I like having ivy in a popup.
Problem: posframe does not work if emacs is too old and on macos.
See here: https://github.com/tumashu/posframe/issues/30
On Mac, ~brew install --HEAD emacs~ doesn't work either.
Solution: ~brew tap daviderestivo/emacs-head && brew install emacs-head@28 --with-cocoa~

#+begin_src emacs-lisp
  (if (and ( version< emacs-version "28") (equal system-type 'darwin))
      (message "ivy-posframe won't work properly, run `brew install daviderestivo/emacs-head/emacs-head@28 --with-cocoa`")
    (use-package ivy-posframe
      :config
      (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
      (setq ivy-posframe-parameters
            '((left-fringe . 8)
              (right-fringe . 8)))
      (setq ivy-posframe-border-width 10)
      (custom-set-faces '(ivy-posframe-border ((t (:inherit mode-line-inactive)))))
      (ivy-posframe-mode 1)))
#+end_src
** avy
This lets me jump to any position in Emacs rather quickly, sometimes it's useful.
~avy-goto-char-timer~ lets me type a part of the text before avy kicks in.

#+begin_src emacs-lisp
  (use-package avy
    :bind
    (("C-:" . 'avy-goto-char-timer)))
#+end_src

** org
In org mode, I want to use bullets instead of stars, so I also install ~org-bullets~.

#+begin_src emacs-lisp
  (use-package org
    :config
    (unless (package-installed-p 'org-bullets)
      (package-refresh-contents)
      (package-install 'org-bullets))
    (use-package org-bullets)
    (require 'org-tempo)
    (require 'org-habit)

    :hook
    (org-mode . (lambda () (org-bullets-mode 1)))
    :bind
    (("C-c a" . org-agenda)
     ("C-c n" . org-capture)
     ("C-c l" . org-store-link)))
#+end_src

To be able to link to emails via notmuch, I use ol-notmuch:

#+begin_src emacs-lisp
  (use-package ol-notmuch :quelpa)
#+end_src

** lean-mode
Specifically for the Lean prover.
I also install company-lean and helm-lean, which are suggested on the [[https://github.com/leanprover/lean-mode][Github page]].
Then I map company-complete only for lean-mode.

#+begin_src emacs-lisp
  (use-package lean-mode
    :config
    (use-package company-lean)
    :hook
    (lean-mode . (lambda () (define-key lean-mode-map (kbd "S-SPC") #'company-complete))))
#+end_src

** magit
#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** vterm
Emacs has a bunch of built-in terminal emulators.
And they all suck.
(OK not really, eshell is alright, but not for interactive terminal programs like newsboat/neomutt)

Also use emacsclient inside vterm as an editor, because that'll open documents in the existing Emacs session.
And I'm not gonna be a heretic and open Vim inside of Emacs.

#+begin_src emacs-lisp
  (use-package vterm
    :config
    (setq vterm-environment '("EDITOR=emacsclient"))
    :hook
    (vterm-mode . (lambda () (unless server-process (server-start)))))
#+end_src

I'll bind a key to start a vterm or switch to the running vterm:

#+begin_src emacs-lisp
  (defun switch-to-vterm () "Switch to a running vterm, or start one and switch to it."
         (interactive)
         (if (get-buffer vterm-buffer-name)
             (switch-to-buffer vterm-buffer-name)
           (vterm)))
  (global-set-key (kbd "C-c t") 'switch-to-vterm)
#+end_src

** sr-speedbar
Make speed bar show in the current frame.

#+begin_src emacs-lisp
  (use-package sr-speedbar
    :config
    (setq sr-speedbar-right-side nil)
    (define-key speedbar-mode-map (kbd "q") 'sr-speedbar-close))

#+end_src

Jump to speedbar. sr-speedbar-exist-p can be void, so I check if it's bound first.
If it's not bound, or if it's false, first open the speedbar.
Then, select it.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c F") (lambda () (interactive)
                                  (if (or (not (boundp 'sr-speedbar-exist-p))
                                          (not (sr-speedbar-exist-p)))
                                      (sr-speedbar-open))
                                  (sr-speedbar-select-window)))
#+end_src

** expand-region
Expand the selected region semantically.

#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src

** flycheck
Install flycheck, and enable it by default in certain major modes:

#+begin_src emacs-lisp
  (use-package flycheck
    :hook (sh-mode . flycheck-mode))
#+end_src

** anki-editor
Some extra keybindings that are not set up by default.
anki-editor doesn't provide a keymap so I have to set one up here:

#+begin_src emacs-lisp
  (use-package anki-editor
    :config
    (defvar anki-editor-mode-map (make-sparse-keymap))
    (add-to-list 'minor-mode-map-alist (cons 'anki-editor-mode
                                             anki-editor-mode-map))

    (setq anki-editor-use-math-jax t)

    :hook
    (anki-editor-mode . (lambda ()
                          (define-key anki-editor-mode-map (kbd "C-c t") #'org-property-next-allowed-value)
                          (define-key anki-editor-mode-map (kbd "C-c i") #'anki-editor-insert-note)
                          (define-key anki-editor-mode-map (kbd "C-c p") #'anki-editor-push-notes)
                          (define-key anki-editor-mode-map (kbd "C-c c") #'anki-editor-cloze-dwim))))
#+end_src

** rainbow-mode
'rainbow-mode' lets you visualise hex colors:

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :hook (emacs-lisp-mode . rainbow-mode))
#+end_src

** pdf-tools
A better replacement for DocView:

#+begin_src emacs-lisp
  (use-package pdf-tools
    :config
    (setq-default pdf-annot-default-annotation-properties '((t
                                                             (label . "Alex Balgavy"))
                                                            (text
                                                             (icon . "Note")
                                                             (color . "#0088ff"))
                                                            (highlight
                                                             (color . "yellow"))
                                                            (squiggly
                                                             (color . "orange"))
                                                            (strike-out
                                                             (color . "red"))
                                                            (underline
                                                             (color . "blue"))))
    :hook
    (pdf-annot-list-mode . pdf-annot-list-follow-minor-mode)
    (pdf-annot-edit-contents-minor-mode . org-mode)
    (pdf-view-mode . (lambda () (display-line-numbers-mode 0)))
    (pdf-view-mode . (lambda () (define-key pdf-isearch-minor-mode-map (kbd "C-s") #'isearch-forward))))
  (pdf-tools-install)
#+end_src

** virtualenvwrapper
Like virtualenvwrapper.sh, but for Emacs.

#+begin_src emacs-lisp
  (use-package virtualenvwrapper
    :config
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    (setq venv-location "~/.config/virtualenvs"))
#+end_src

** org-ref
#+begin_src emacs-lisp
  (use-package org-ref)
#+end_src

** org-noter
#+begin_src emacs-lisp
  (use-package org-noter)
#+end_src

** hl-todo
I want to highlight TODO keywords in comments:

#+begin_src emacs-lisp
  (use-package hl-todo
    :custom-face
    (hl-todo ((t (:inherit hl-todo :underline t))))
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#ff7060")
            ("FIXME"  . "#caa000")))
    (global-hl-todo-mode t))
#+end_src
** undo-tree
Sometimes it's better to look at undo history as a tree:

#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode))
#+end_src

* Interface
** Start debugger on error
#+begin_src emacs-lisp
  ;; (toggle-debug-on-error t)
#+end_src

** Messages
Hide some messages I don't need.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq initial-scratch-message "")
#+end_src

** Appearance
*** Cursor line
Highlight the current line:

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src
*** Matching parentheses
Don't add a delay to show matching parenthesis.
Must come before show-paren-mode enable.

#+begin_src emacs-lisp
  (setq show-paren-delay 0)
#+end_src

Show matching parentheses:

#+begin_src emacs-lisp
  (show-paren-mode t)
#+end_src

*** Cursor
The default box cursor isn't really accurate, because the cursor is actually between letters, not on a letter.
So, I want a bar instead of a box:

#+begin_src emacs-lisp
  (setq-default cursor-type '(bar . 4)
                cursor-in-non-selected-windows 'hollow)
#+end_src

(I use ~setq-default~ here because cursor-type is automatically buffer-local when it's set)

*** Line numbers
Relative line numbers:

#+begin_src emacs-lisp
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)
#+end_src

Don't display them in specific modes.  For each of the modes in
'mode-hooks', add a function to hide line numbers when the mode
activates (which triggers the 'mode'-hook).

#+begin_src emacs-lisp
  (let ((mode-hooks '(doc-view-mode-hook vterm-mode-hook mpc-status-mode-hook mpc-tagbrowser-mode-hook)))
    (mapc
     (lambda (mode-name)
       (add-hook mode-name (lambda () (display-line-numbers-mode 0))))
     mode-hooks))
#+end_src
*** Modeline
I want to show the time and date in the modeline:

#+begin_src emacs-lisp
  (setq display-time-day-and-date t           ; also the date
        display-time-default-load-average nil ; don't show load average
        display-time-format "%I:%M%p %e %b (%a)")   ; "HR:MIN(AM/PM) day-of-month Month (Day)"
  (display-time-mode 1)                  ; enable time mode
#+end_src

I want to show the current function:

#+begin_src emacs-lisp
  (which-function-mode 1)
#+end_src

And to set the modeline format:

#+begin_src emacs-lisp
  (setq-default mode-line-format '("%e" mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified mode-line-remote mode-line-frame-identification mode-line-buffer-identification "   " mode-line-position
                                   (vc-mode vc-mode)
                                   "  " mode-line-modes mode-line-misc-info mode-line-end-spaces))
#+end_src

I want to hide certain modes from the modeline, they're always on:

#+begin_src emacs-lisp
  (use-package diminish
    :config
    (let ((modes-to-hide '(ivy-mode counsel-mode which-key-mode hl-todo-mode)))
      (mapc (lambda (mode-name) (diminish mode-name)) modes-to-hide)))
#+end_src

** Buffer displaying

So, this is a bit hard to grok. But basically the alist contains a
regular expression to match a buffer name, then a list of functions to
use in order for displaying the list, and then options for those functions (each of which is an alist).

#+begin_src emacs-lisp
  (setq
   ;; Maximum number of side-windows to create on (left top right bottom)
   window-sides-slots '(0   ;; left
                        1   ;; top
                        3   ;; right
                        1 ) ;; bottom

   display-buffer-alist '(
                          ;; Right side
                          ("\\*Help\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . -1)
                           (inhibit-same-window . t))
                          ("\\*Async Shell Command\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . 0)
                           (inhibit-same-window . t))
                          ("magit-process: .*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . right)
                           (slot . 0)
                           (inhibit-same-window . t))

                          ;; Top side
                          ("\\*Info\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . top)
                           (slot . 0))
                          ("\\*Man .*\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . top)
                           (slot . 0))

                          ;; Bottom
                          ("\\*Flycheck errors\\*"
                           (display-buffer-reuse-window display-buffer-in-side-window)
                           (side . bottom)
                           (slot . 0))))
#+end_src

And a way to toggle those side windows:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w") (lambda () (interactive) (window-toggle-side-windows)))
#+end_src
* Emacs file locations
** Auto-Save files
By default, auto-save files ("#file#") are placed in the same directory as the file itself.
I want to put this all in some unified place:

#+begin_src emacs-lisp
  (let ((saves-directory "~/.local/share/emacs/saves/"))
    (unless (file-directory-p saves-directory)
      (make-directory saves-directory))
    (setq auto-save-file-name-transforms
          `((".*" ,saves-directory t))))
#+end_src

** Backup files
By default, backup files (those with a tilde) are saved in the same directory as the currently edited file.
This setting puts them in ~/.local/share/emacs/backups.

#+begin_src emacs-lisp
  (let ((backups-directory "~/.local/share/emacs/backups"))
    (unless (file-directory-p backups-directory)
      (make-directory backups-directory))
    (setq backup-directory-alist `(("." . ,backups-directory)))
    (setq backup-by-copying t))
#+end_src

** Custom settings file
Both commands are necessary.
First one tells Emacs where to save customizations.
The second one actually loads them.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name (concat user-emacs-directory "custom.el")))
  (load custom-file)
#+end_src

* Editor
** Overwrite selection on typing
Normally, when I select something and start typing, Emacs clears the selection, i.e. it deselects and inserts text after the cursor.
I want to replace the selection.

#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src

** Strip trailing whitespace
You can show trailing whitespace by setting show-trailing-whitespace to 't'.
But I want to automatically strip trailing whitespace.
Luckily there's already a function for that, I just need to call it in a hook:

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** Formatting & indentation
Disable fill mode in Markdown

#+begin_src emacs-lisp
  (add-hook 'markdown-mode-hook (lambda () (auto-fill-mode 0) (flyspell-mode 1)))
#+end_src

Show a tab as 8 spaces:

#+begin_src emacs-lisp
  (setq-default tab-width 8)
#+end_src

Never insert tabs with indentation by default:

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Allow switching between the two easily:

#+begin_src emacs-lisp
  (defun indent-tabs ()
    (interactive)
    (setq indent-tabs-mode t))
  (defun indent-spaces ()
    (interactive)
    (setq indent-tabs-mode nil))
#+end_src

Indentation for various modes:

#+begin_src emacs-lisp
  (setq-default sh-basic-offset 2
                c-basic-offset 4)
#+end_src

** Wrapping
I want to wrap text at window boundary for some modes:

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook (lambda ()
                             (visual-line-mode)
                             (org-indent-mode)))
  (add-hook 'markdown-mode-hook (lambda () (visual-line-mode)))
#+end_src

** Pulse line
When you switch windows, Emacs can flash the cursor briefly to guide your eyes; I like that.
Set some options for pulsing:

#+begin_src emacs-lisp
  (setq pulse-iterations 10)
  (setq pulse-delay 0.05)
#+end_src

Define the pulse function:

#+begin_src emacs-lisp
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))
#+end_src

Run it in certain cases: scrolling up/down, recentering, switching windows.
'dolist' binds 'command' to each value in the list in turn, and runs the body.
'advice-add' makes the pulse-line function run after 'command'.

#+begin_src emacs-lisp
  (dolist (command '(scroll-up-command scroll-down-command recenter-top-bottom other-window))
    (advice-add command :after #'pulse-line))
#+end_src

And set the pulse color:

#+begin_src emacs-lisp
  (custom-set-faces '(pulse-highlight-start-face ((t (:background "CadetBlue2")))))
#+end_src

** Pager mode
M-x view-mode enables pager behavior.
I want read-only files to automatically use pager mode:

#+begin_src emacs-lisp
  (setq view-read-only t)
#+end_src
** Mail mode for neomutt
When editing a message from neomutt, I want to use mail mode.
Even though I won't be sending the email from there, I like the syntax highlighting :)

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("/neomutt-" . mail-mode))
#+end_src
** Zap up to char
It's more useful for me to be able to delete up to a character instead of to and including a character:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+end_src
** Expansion/completion
Use hippie expand instead of dabbrev-expand:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+end_src

** Prefer newer file loading
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

** Automatically find tags file
When opening a file in a git repo, try to discover the etags file:

#+begin_src emacs-lisp
  (defun current-tags-file ()
    "Get current tags file"
    (let* ((tagspath ".git/etags")
           (git-root (locate-dominating-file (buffer-file-name) tagspath)))
      (if git-root
          (expand-file-name tagspath git-root))))

  (setq default-tags-table-function #'current-tags-file)
#+end_src

There's probably a better way to write this. I need to ask Reddit for feedback at some point.

** Semantic mode
Set default submodes:

#+begin_src emacs-lisp
  (setq semantic-default-submodes '(global-semantic-idle-scheduler-mode ; reparse buffer when idle
                                    global-semanticdb-minor-mode ; maintain database
                                    global-semantic-idle-summary-mode)) ; show information (e.g. types) about tag at point
  ;; global-semantic-stickyfunc-mode)) ; show current func in header line
#+end_src

Add some keybindings:

#+begin_src emacs-lisp
  (with-eval-after-load 'semantic
    (define-key semantic-mode-map (kbd "C-c , .") #'semantic-ia-show-summary))
#+end_src

SemanticDB is written into ~/.emacs.d/semanticdb/.

Enable semantic mode for major modes:

#+begin_src emacs-lisp
  (let ((mode-hooks [c-mode-common-hook]))
    (mapc (lambda (mode-name)
            (add-hook mode-name (lambda () (semantic-mode 1))))
          mode-hooks))
#+end_src

** Forward-word and forward-to-word
Change M-f to stop at the start of the word:

#+begin_src emacs-lisp
  (global-set-key (kbd "M-f") 'forward-to-word)
#+end_src

Bind C-M-S-F to the old functionality of M-f (stop at end of word)

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-S-F") 'forward-word)
#+end_src

** Rectangle insert string
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x r I") 'string-insert-rectangle)
  (global-set-key (kbd "C-x r R") 'replace-rectangle)
#+end_src
** End sentences with one space
Emacs uses the rather old-fashioned convention of treating a period followed by double spaces as end of sentence. However, it is more common these days to end sentences with a period followed by a single space.

Let a period followed by a single space be treated as end of sentence:

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)
#+end_src

* Org mode
** Agenda & GTD
*** Set file locations
Tell org where to find my stuff

#+begin_src emacs-lisp
  (setq org-life-dir "~/Documents/life/"
        org-life-inbox (concat org-life-dir "inbox.org")
        org-life-main (concat org-life-dir "life.org")
        org-life-tickler (concat org-life-dir "tickler.org")
        org-life-someday (concat org-life-dir "someday.org")
        org-life-archive (concat org-life-dir "archive.org"))
#+end_src

Which files should be included in the agenda (I have to use ~list~ to evaluate the variables, because org-agenda-files expects strings):

#+begin_src emacs-lisp
  (setq org-agenda-files (list org-life-main
                               org-life-inbox
                               org-life-tickler))
#+end_src

Convenience function to make opening the main file faster:

#+begin_src emacs-lisp
  (defun gtd () (interactive) (find-file org-life-main))
#+end_src

*** Refiling & archiving
Where I want to be able to move subtrees (doesn't include inbox because I never refile to that, and the archive has its own keybining):

#+begin_src emacs-lisp
  (setq org-refile-targets `((,org-life-main :maxlevel . 3)
                             (,org-life-someday :level . 1)
                             (,org-life-tickler :maxlevel . 2)))
#+end_src

Include the destination file as an element in the path to a heading, and to use the full paths as completion targets rather than just the heading text itself:

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path 'file)
#+end_src

Tell Org that I don’t want to complete in steps; I want Org to generate all of the possible completions and present them at once (necessary for Helm/Ivy):

#+begin_src emacs-lisp
  (setq org-outline-path-complete-in-steps nil)
#+end_src

Allow me to tack new heading names onto the end of my outline path, and if I am asking to create new ones, make me confirm it:

#+begin_src emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

I want to archive to a specific file, in a date tree:

#+begin_src emacs-lisp
  (setq org-archive-location (concat org-life-archive "::datetree/"))
#+end_src

*** Quick capture
Quick capture lets me send something to my inbox very quickly, without thinking about where it should go.
The inbox is processed later.

Templates for quick capture:

#+begin_src emacs-lisp
  (setq org-capture-templates `(("t" "Todo [inbox]" entry
                                 (file ,org-life-inbox)
                                 "* TODO %i%?")

                                ("s" "Save for read/watch/listen" entry
                                 (file ,org-life-inbox)
                                 "* TODO %?[[%^{link}][%^{description}]] %^G")))
#+end_src

*** Todo & agenda views
Todo keywords based on the GTD system (pipe separates incomplete from complete):
#+begin_src emacs-lisp
  (setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "SOMEDAY(s)" "|" "DONE(d)" "CANCELLED(c)"))
        org-todo-keyword-faces '(("TODO" . org-todo)
                                 ("NEXT" . org-todo)
                                 ("WAITING" . org-todo)
                                 ("SOMEDAY" . org-todo)
                                 ("DONE" . org-done)
                                 ("CANCELLED" . org-done)))
#+end_src

Define a function to skip tasks (trees) that are not habits (i.e. don't have the STYLE property ~habit~):

#+begin_src emacs-lisp
  (defun my-skip-unless-habit ()
    "Skip trees that are not habits"
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          nil
        subtree-end)))
#+end_src

I decided that projects will not be TODO items, but their progress will be tracked with a progress cookie ([x/y]). This function converts an item to a project: it adds a PROJECT tag, sets the progress indicator to count all checkboxes in sub-items (only TODO items), and removes any existing TODO keywords. Finally, PROJECT tags shouldn't be inherited (i.e. subtasks shouldn't be marked as projects).

#+begin_src emacs-lisp
  (defun my-mark-as-project ()
    "This function makes sure that the current heading has
      (1) the tag PROJECT
      (2) the property COOKIE_DATA set to \"todo recursive\"
      (3) a leading progress indicator"
    (interactive)
    (org-set-property "TODO" "")
    (org-toggle-tag "PROJECT" 'on)
    (org-set-property "COOKIE_DATA" "todo recursive")
    (org-back-to-heading t)
    (forward-whitespace 1)
    (insert "[/] ")
    (org-update-statistics-cookies nil))
  (setq org-tags-exclude-from-inheritance '("PROJECT"))
#+end_src

Create custom agenda view based on those keywords.
Agenda views are made up of blocks, appearing in the order that you declare them.
The first two strings are what shows up in the agenda dispatcher (the key to press and the description).

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("n" "Next actions"
           ((todo "NEXT" ((org-agenda-overriding-header "Next actions:")))))

          ("w" "Week Agenda + Next Actions"
           ((agenda "" ((org-agenda-overriding-header "Week agenda:")))
            (todo "NEXT" ((org-agenda-overriding-header "Next actions:")))))
          ("o" "Month agenda"
           ((agenda "" ((org-agenda-overriding-header "Month agenda:")
                        (org-agenda-span 'month)))))

          ("d" "Day Agenda + Next Actions + Habits"
           ((agenda "" ((org-agenda-overriding-header "Day:")
                        (org-agenda-span 'day)
                        (org-habit-show-habits nil)))
            (agenda "" ((org-agenda-span 'day)
                        (org-agenda-use-time-grid nil)
                        (org-agenda-skip-function 'my-skip-unless-habit)
                        (org-agenda-overriding-header "Habits:")
                        (org-habit-show-habits t) (org-habit-show-habits-only-for-today nil)
                        (org-habit-show-all-today t)))
            (todo "NEXT" ((org-agenda-overriding-header "Next actions:")))))

          ("p" "Projects"
           ((tags "PROJECT" ((org-agenda-overriding-header "Projects:")))))))

#+end_src

*** Logging
I want to log into the LOGBOOK drawer (useful when I want to take quick notes):

#+begin_src emacs-lisp
  (setq org-log-into-drawer "LOGBOOK")
#+end_src

I also want to log when I finish a task (useful for archiving).
Furthermore, when I'm done, I want to add a note (any important
workarounds/tips). And when I reschedule, I want to know the reason.
I can disable logging on state change for a specific task by adding ~:LOGGING: nil~ to the ~:PROPERTIES:~ drawer.

#+begin_src emacs-lisp
  (setq org-log-done 'note
        org-log-reschedule 'note)
#+end_src

I want to hide drawers on startup. This variable has options:
- 'overview': Top-level headlines only.
- 'content': All headlines.
- 'showall': No folding on any entry.
- 'show2levels: Headline levels 1-2.
- 'show3levels: Headline levels 1-3.
- 'show4levels: Headline levels 1-4.
- 'show5levels: Headline levels 1-5.
- 'showeverything: Show even drawer contents.

#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

*** Task ordering
Some tasks should be ordered, i.e. they should be done in steps.
Those have the ~:ORDERED: t~ setting in ~:PROPERTIES:~, and it should be enforced:

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
#+end_src

Furthermore, tasks that are ordered and can't be done yet because of previous steps should be dimmed in the agenda:

#+begin_src emacs-lisp
  (setq org-agenda-dim-blocked-tasks t)
#+end_src

I might also want to set ~org-enforce-todo-checkbox-dependencies~, but not convinced on that one yet.

*** Time tracking & effort
Time tracking should be done in its own drawer:

#+begin_src emacs-lisp
  (setq org-clock-into-drawer "CLOCKING")
#+end_src

I want to set effort in hours:minutes:

#+begin_src emacs-lisp
  (add-to-list 'org-global-properties '("Effort_ALL" . "0:05 0:10 0:15 0:20 0:30 1:00 1:30 2:00 4:00 6:00 8:00"))
#+end_src

I want column view to look like this:

| To do        | Task      | Tags | Sum of time elapsed | Sum of time estimated (effort) |
|--------------+-----------+------+---------------------+--------------------------------|
| todo keyword | task name | tags | sum of clock        | sum of estimated time          |
| ...          | ...       | ...  | ...                 | ...                            |

#+begin_src emacs-lisp
  (setq org-columns-default-format "%7TODO (To Do) %32ITEM(Task) %TAGS(Tags) %6CLOCKSUM(Clock) %8Effort(Effort){:}")
#+end_src

** Tempo expansions

#+begin_src emacs-lisp
  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sb" . "src bibtex"))
#+end_src

** Yank URL
#+begin_src emacs-lisp
  (defun org-yank-link-url ()
    (interactive)
    (kill-new (org-element-property :raw-link (org-element-context))))

  (define-key org-mode-map (kbd "C-c M-y") 'org-yank-link-url)
#+end_src

** Catch invisible edits
Sometimes when text is folded away, I might accidentally edit text inside of it.
This option prevents that.
I wanted to do 'smart', but that has a 'fixme' so it might change in the future...
Instead, show what's being edited, but don't perform the edit.

#+begin_src emacs-lisp
  (setq org-catch-invisible-edits 'show-and-error)
#+end_src

** Notification
macOS doesn't have dbus. So I use terminal-notifier for functions like org-notify:

#+begin_src emacs-lisp
  (if (and (eq system-type 'darwin)
           (executable-find "terminal-notifier"))
      (setq org-show-notification-handler
            (lambda (str) (start-process "terminal-notifier" nil (executable-find "terminal-notifier")
                                         "-title" "Timer done"
                                         "-message" str
                                         "-group" "org.gnu.Emacs"
                                         "-sender" "org.gnu.Emacs"))))
#+end_src
* Bib(la)tex
#+begin_src emacs-lisp
  (add-hook 'bibtex-mode-hook (lambda () (bibtex-set-dialect "biblatex")))
#+end_src

* Python
In Python, I want to enable flycheck and semantic mode:

#+begin_src emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
  (add-hook 'python-mode-hook 'semantic-mode)
#+end_src

* Misc settings
** Enable all commands
By default, Emacs disables some commands.
I want to have these enabled so I don't get a prompt whenever I try to use a disabled command.

#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

** More extensive apropos
#+begin_src emacs-lisp
  (setq apropos-do-all t)
#+end_src
** Easily edit my config
Bind a keyboard shortcut to open my config.
The "(interactive)" means that it can be called from a keybinding or from M-x (though since it's a lambda, it can't be called from M-x).

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c E") (lambda () (interactive) (find-file (expand-file-name "config.org" user-emacs-directory))))
#+end_src
** Fast access to view-mode (pager)
I want to bind view-mode to a key for easy access:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") 'view-mode)
#+end_src

** Kill this buffer
I like to be able to kill a buffer instantly:

#+begin_src emacs-lisp
  (global-set-key (kbd "s-<backspace>") 'kill-current-buffer)
#+end_src

** Toggle fullscreen
I'll use the keybinding that's standard on macOS:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-s-f") #'toggle-frame-fullscreen)
#+end_src

** Enable recursive minibuffers
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t
        minibuffer-depth-indicate-mode t)
#+end_src

** Sexp manipulation
When I write lisp, sometimes I want to switch two sexps (e.g. ~(one) (two)~ → ~(two) (one)~), so a key binding is nice for that:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-S-t") #'transpose-sexps)
#+end_src

Also, to raise a sexp (e.g. ~(one (two))~ → ~(two)~):

#+begin_src emacs-lisp
  (global-set-key (kbd "C-S-u") #'raise-sexp)
#+end_src

* Notmuch
Define some saved searches (i.e. mailboxes):

#+begin_src emacs-lisp
  (setq notmuch-saved-searches
        `((:name "inbox: personal" :query "folder:/alex@balgavy.eu/ tag:inbox" :key ,(kbd "ip"))
          (:name "inbox: school" :query "folder:/a.balgavy@student.vu.nl/ tag:inbox" :key ,(kbd "is"))
          (:name "archive: personal" :query "folder:/alex@balgavy.eu/ tag:archive" :key ,(kbd "ap"))
          (:name "archive: school" :query "folder:/a.balgavy@student.vu.nl/ tag:archive" :key ,(kbd "as"))))
#+end_src

Define the main screen sections:

#+begin_src emacs-lisp
  (setq notmuch-hello-sections
        '(notmuch-hello-insert-header
          notmuch-hello-insert-saved-searches
          notmuch-hello-insert-search
          notmuch-hello-insert-alltags
          notmuch-hello-insert-footer))
#+end_src

Global keybindings:

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c m") #'notmuch)
#+end_src

Show newest mail first:

#+begin_src emacs-lisp
  (setq notmuch-search-oldest-first nil)
#+end_src

Set tags:

#+begin_src emacs-lisp
  (setq notmuch-archive-tags '("-inbox" "+archive"))
  (setq notmuch-show-mark-unread-tags '("+unread"))
  (setq notmuch-delete-tags '("-inbox" "+trash"))

  (setq notmuch-tagging-keys '(("a" notmuch-archive-tags "Archive")
                               ("r" notmuch-show-mark-read-tags "Mark read")
                               ("u" notmuch-show-mark-unread-tags "Mark unread")
                               ("d" notmuch-delete-tags "Delete")))
#+end_src

Run notmuch-hook script on hello refresh, to move messages to folders according to their tags:

#+begin_src emacs-lisp
  (add-hook 'notmuch-hello-refresh-hook (lambda () (start-process "notmuch-hook" nil "notmuch-hook" "tags2folders")))
#+end_src
* MPC
Set the windows I want to show:

#+begin_src emacs-lisp
  (setq mpc-browser-tags '(AlbumArtist Album Genre Playlist))
#+end_src

Define some keybindings:

#+begin_src emacs-lisp
  (add-hook 'mpc-mode-hook
            (lambda ()
              (define-key mpc-mode-map "a" #'mpc-playlist-add)
              (define-key mpc-mode-map "P" #'mpc-playlist)
              (define-key mpc-mode-map "x" #'mpc-playlist-delete)
              (define-key mpc-mode-map "p" #'mpc-toggle-play)
              (define-key mpc-mode-map "t" #'mpc-select-toggle)
              (define-key mpc-mode-map "f" (lambda () "Seek forward 20 seconds" (interactive) (mpc-seek-current "+20")))
              (define-key mpc-mode-map "b" (lambda () "Seek backward 20 seconds" (interactive) (mpc-seek-current "-20")))))
#+end_src

Unfortunately the lambda keybindings don't show up documented properly, but oh well. That's a minor problem.

* Radio
Just a wrapper function to my radio script:

#+begin_src emacs-lisp
  (defun radio ()
    "Play an internet radio"
    (interactive)
    (ansi-term "radio" "*radio*"))
#+end_src

* Dired
'i' expands subdirs, so I want to be able to close them too.

#+begin_src emacs-lisp
  (define-key dired-mode-map (kbd "M-k") #'dired-kill-subdir)
#+end_src

Set up listing display:

#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-alhv")
#+end_src

By default, hide details (show again by pressing oparen):

#+begin_src emacs-lisp
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+end_src

If I have another dired window open, use that as target:

#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src

* References
Here's a list of good articles I encountered about configging emacs:
- [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]]
- [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with emacs]]

For Org mode, [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][Rainer König's tutorials]] are the best.
[[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][Here's a good reference for setting up gtd in org mode]]
