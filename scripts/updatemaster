#!/usr/bin/env ruby
# frozen_string_literal: true
# TODO: check caffeinate termination

def check_deps(deps)
  deps.each do |dep|
    unless system("command -v #{dep} >/dev/null 2>&1")
      warn "error: command #{dep} not found"
      exit 1
    end
  end
end

def stay_awake
  system `caffeinate -d`
end

# The Homebrew package manager for macOS
class Homebrew
  def initialize
    check_deps ['brew']
    puts '-- HOMEBREW --'
    2.times { system 'brew update' }
    @outdated_casks = `brew outdated --cask --greedy --verbose`.lines.map(&:chomp)
    @cask_names = @outdated_casks.map { |c| c.split.first }
    @outdated_formulae = `brew outdated --formula`
  end

  def prompt_user
    puts "\nOutdated casks:"
    @outdated_casks.each_with_index { |c, i| puts "#{i} #{c}" }
    print 'Numbers of casks to upgrade (space-separated): '
    begin
      @to_upgrade = gets.chomp.split.map { |casknum| @cask_names[Integer(casknum)] }
    rescue ArgumentError
      warn 'Only numbers allowed'
      exit 1
    end

    puts "Please enter the administrator password to install cask upgrades."
    system 'sudo -v'
    @sudo_cache_pid = spawn "while :; do sudo -n true; sleep 60; done 2>/dev/null"
  end

  def do_upgrade
    puts "\nUpgrading all formulae.\nTo upgrade:"
    puts @outdated_formulae
    system 'brew upgrade --formula'

    puts "\nUpgrading casks:"
    puts @to_upgrade

    @to_upgrade.each { |cask| system "brew upgrade --cask --greedy --verbose #{cask}" }
    puts 'Upgrade complete.'
  end

  def cleanup
    Process.kill "TERM", @sudo_cache_pid
    system 'brew cleanup -s --prune-prefix'
    system 'brew cleanup'
    system 'brew doctor'
    system 'brew missing'

    puts "Homebrew cache disk usage: #{`du -skh "$(brew --cache)" | cut -f1`}"
    puts "Remove with:\trm -rf $(brew --cache)"
    system 'brew bundle dump --force --file=~/.dotfiles/Brewfile;'
  end
end

# Pipx for Python
class Pipx
  def initialize
    check_deps ['pipx']
    puts '-- PIPX --'
  end

  def do_upgrade
    system 'pipx upgrade-all'
  end
end

begin
  caffeine_thread = Thread.new { stay_awake }
  package_systems = [Homebrew, Pipx]

  # Do all the prompting up front
  systems_with_prompt = package_systems.select { |s| s.method_defined? 'prompt_user' }
  unless systems_with_prompt.empty?
    system_instances = systems_with_prompt.map(&:new)
    system_instances.each(&:prompt_user)
    system_instances.each do |pksys|
      pksys.do_upgrade
      pksys.cleanup if pksys.class.method_defined? 'cleanup'
    end
    package_systems -= systems_with_prompt
  end

  # Complete remaining package systems
  package_systems.each do |pksys_class|
    pksys = pksys_class.new
    pksys.prompt_user if pksys_class.method_defined? 'prompt_user'
    pksys.do_upgrade
    pksys.cleanup if pksys.class.method_defined? 'cleanup'
  end
rescue SystemExit, Interrupt
  caffeine_thread.join
  exit 0
end
